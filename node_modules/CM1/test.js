var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = x + '/package.json';
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

require.define = function (filename, fn) {
    var dirname = require._core[filename]
        ? ''
        : require.modules.path().dirname(filename)
    ;
    
    var require_ = function (file) {
        return require(file, dirname)
    };
    require_.resolve = function (name) {
        return require.resolve(name, dirname);
    };
    require_.modules = require.modules;
    require_.define = require.define;
    var module_ = { exports : {} };
    
    require.modules[filename] = function () {
        require.modules[filename]._cached = module_.exports;
        fn.call(
            module_.exports,
            require_,
            module_,
            module_.exports,
            dirname,
            filename
        );
        require.modules[filename]._cached = module_.exports;
        return module_.exports;
    };
};

if (typeof process === 'undefined') process = {};

if (!process.nextTick) process.nextTick = (function () {
    var queue = [];
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;
    
    if (canPost) {
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);
    }
    
    return function (fn) {
        if (canPost) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        }
        else setTimeout(fn, 0);
    };
})();

if (!process.title) process.title = 'browser';

if (!process.binding) process.binding = function (name) {
    if (name === 'evals') return require('vm')
    else throw new Error('No such module')
};

if (!process.cwd) process.cwd = function () { return '.' };

require.define("path", function (require, module, exports, __dirname, __filename) {
function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

});

require.define("/node_modules/testling/package.json", function (require, module, exports, __dirname, __filename) {
module.exports = {"main":"index.js"}
});

require.define("/node_modules/testling/index.js", function (require, module, exports, __dirname, __filename) {
var outputs = {
    text : require('./lib/output/text')
};

var outputName = process.env.TESTLING_OUTPUT || 'text';
if (outputs[outputName]) {
    var output = outputs[outputName]();
}
else {
    throw [
        'Output format ' + JSON.stringify(outputName) + ' not supported.',
        'Export TESTLING_OUTPUT to set the output format.',
        'Available formats:',
        Object.keys(outputs).map(function (name) {
            return '    ' + name
        }).join('\r\n'),
        ''
    ].join('\r\n');
}

var test = module.exports = require('./lib/test');
test.output = output;

test.push = function (name, res) {
    res.browser = test.browser || 'node/jsdom';
    output(name, res);
};
output('visit', test.browser || 'node/jsdom');
output('launched', test.browser || 'node/jsdom');

});

require.define("/node_modules/testling/lib/output/text.js", function (require, module, exports, __dirname, __filename) {
var fs = require('fs');

module.exports = function () {
    var handler = new Handler;
    
    return function (name, res) {
        if (handler[name]) {
            handler[name](res);
        }
        else {
            console.error('\r\nUnknown event: ' + name);
        }
    };
};

function stringify (obj) {
    return JSON.stringify(obj);
}

function Handler () {
    this.counts = {};
    this.fails = {};
}

Handler.prototype.testBegin = function () {};
Handler.prototype.testEnd = function () {};

Handler.prototype.log = function (res) {
    this.fails[res.browser].push([ 'log', res ]);
};

Handler.prototype.visit = function (key) {
    this.fails[key] = [];
    this.write('\r' + key + '    ');
};

Handler.prototype.launched = function (key) {    
    this.fails[key] = [];
    this.writeBrowser(key);
};

Handler.prototype.assert = function (res) {
    var key = res.browser;
    var id = res.testId || 'init';
    
    var counts = this.counts;
    var fails = this.fails;
    
    if (!counts[key]) counts[key] = { inits : { pass : 0, fail : 0 } };
    if (!counts[key][id]) counts[key][id] = { pass : 0, fail : 0 };
    var count = counts[key][id];
    
    if (res.ok) count.pass ++;
    else {
        count.fail ++;
        fails[key].push([ 'assert', res ]);
    }
    if (count.plan) this.writeBrowser(key);
};

Handler.prototype.plan = function (res) {
    var key = res.browser;
    var id = res.testId || 'init';
    var counts = this.counts;
    
    if (key) {
        if (!counts[key]) counts[key] = { inits : { pass : 0, fail : 0 } };
        if (!counts[key][id]) counts[key][id] = { pass : 0, fail : 0 };
        var count = counts[key][id];
        
        if (res.n) count.plan = res.n;
    }
};

Handler.prototype.end = function (res) {
    var self = this;
    
    var key = res.browser;
    var id = res.testId || 'init';
    
    this.writeBrowser(key);
    this.write('\r\n');
    
    (this.fails[key] || []).forEach(function (xs) {
        function str (x) {
            return JSON.stringify(x);
        }
        
        var name = xs[0];
        if (name === 'log') {
            var m = xs[1].message;
            self.write('  Log: '
                + (typeof m === 'string' ? m : str(m))
                + '\r\n'
            );
        }
        else if (name === 'assert' && xs[1].type === 'error') {
            var err = xs[1].error;
            var msg = err && err.message || err;
            self.write('  Error: ' + msg + '\r\n');
            if (err.stack) {
                var s = err.stack.split(/\r?\n/).slice(1).join('\r\n');
                self.write(s + '\r\n');
            }
        }
        else if (name === 'assert') {
            var fail = xs[1];
            self.write('  Error in ' + fail.type + '(): ');
            if (fail.type === 'fail') {
                self.write(
                    typeof fail.found === 'string'
                        ? fail.found : str(fail.found)
                );
            }
            else if (fail.type === 'equal') {
                self.write(str(fail.wanted) + ' == ' + str(fail.found));
            }
            else if (fail.type === 'notEqual') {
                self.write(str(fail.wanted) + ' != ' + str(fail.found));
            }
            else if (fail.type === 'strictEqual') {
                self.write(str(fail.wanted) + ' === ' + str(fail.found));
            }
            else if (fail.type === 'strictNotEqual') {
                self.write(str(fail.wanted) + ' !== ' + str(fail.found));
            }
            else if (fail.type === 'ok') {
                self.write('ok(' + str(fail.found) + ')');
            }
            else if (fail.type === 'notOk') {
                self.write('notOk(' + str(fail.found) + ')');
            }
            else {
                self.write('  wanted: ' + str(fail.wanted) + ', '
                    + 'found: ' + str(fail.found) + '\r\n');
            }
            
            self.write('\r\n');
            if (fail.stack) {
                self.write(fail.stack + '\r\n');
                var m = fail.stack.match(/^\s*at (\/[^:]+):(\d+):(\d+)/);
                if (m) {
                    var line = m[2], col = m[3];
                    var lines = fs.readFileSync(m[1], 'utf8').split('\n');
                    var s = lines[line - 1].trim();
                    self.write('\r\n  > ' + s + '\r\n\r\n');
                }
            }
        }
    });
};

Handler.prototype.finished = function () {
    var self = this;
    var total = { pass : 0, fail : 0 };
    var counts = this.counts;
    
    Object.keys(counts).forEach(function (key) {
        Object.keys(counts[key]).forEach(function (id) {
            total.pass += counts[key][id].pass;
            total.fail += counts[key][id].fail;
        });
    });
    
    counts.total = { total : total };
    
    this.write('\r\n');
    this.writeBrowser('total');
    
    process.nextTick(function () {
        self.write('\r\n');
    });
};

Handler.prototype.error = function (res) {
    if (res.browser && this.fails[res.browser]) {
        if (counts[res.browser]) {
            counts[res.browser][res.testId || 'init'].fail ++;
        }
        this.fails[res.browser].push([ 'error', res ]);
    }
    else {
        this.write([
            '',
            'Unexpected error: ' + JSON.stringify(res),
            '',
            ''
        ].join('\r\n'));
    }
};

Handler.prototype.write = function (msg) {
    process.stdout.write(msg);
};

Handler.prototype.writeBrowser = function (key) {
    var counts = this.counts;
    var fails = this.fails;
    
    if (!counts[key]) counts[key] = { init : { pass : 0, fail : 0 } };
    
    var count = Object.keys(counts[key]).reduce(function (acc, id) {
        acc.pass += counts[key][id].pass;
        acc.fail += counts[key][id].fail;
        return acc;
    }, { pass : 0, fail : 0 });
    
    var percent = count.pass + count.fail <= 0
        ? '0'
        : Math.floor(100 * count.pass / (count.pass + count.fail))
    ;
    
    function padRight (n, s) {
        s = s.toString();
        return s + Array(Math.max(0, n + 1 - s.length)).join(' ');
    }
    
    function padLeft (n, s) {
        s = s.toString();
        return Array(Math.max(0, n - s.length) + 1).join(' ') + s;
    }
    
    this.write('\r'
        + padRight(24, key)
        + '  '
        + padLeft(9, count.pass + '/' + (count.pass + count.fail))
        + '  '
        + padLeft(3, percent) + ' % ok'
    );
};

});

require.define("fs", function (require, module, exports, __dirname, __filename) {
// nothing to see here... no file methods for the browser

});

require.define("/node_modules/testling/lib/test.js", function (require, module, exports, __dirname, __filename) {
var http = require('http');
var EventEmitter = require('events').EventEmitter;
var url = require('url');
var path = require('path');

var deepEqual = require('./deep_equal');
var pending = 0;

var test = module.exports = function (name, cb) {
    if (typeof name === 'function') {
        cb = name;
        name = undefined;
    }
    
    var t = new Test(name, test.push);
    pending ++;
    
    t.on('testEnd', function () {
        pending --;
        process.nextTick(function () {
            if (pending <= 0) t.push('end', {});
            harness.emit('end', t);
        });
    });
    
    cb(t);
};

var harness = test.harness = new EventEmitter;

var testId = 0;
function Test (name, push) {
    this.id = testId ++;
    this.push = push;
    push('testBegin', { name : name, testId : this.id });
    
    this.counts = {
        plan : undefined,
        pass : 0,
        fail : 0
    };
    this.windows = [];
}

Test.prototype = new EventEmitter;

Test.prototype.assert = function (res) {
    if (res.ok) this.counts.pass ++
    else this.counts.fail ++
    
    if (this.counts.plan !== undefined
    && this.counts.pass + this.counts.fail > this.counts.plan) {
        this.push('fail', {
            type : 'fail',
            ok : false,
            found : this.counts.fail + this.counts.pass,
            wanted : this.counts.plan,
            name : 'more tests run than planned',
            testId : this.id
        });
    }
    
    res.testId = this.id;
    this.push('assert', res);
    if (!res.ok) res.stack = stack();
    
    if (this.counts.plan !== undefined
    && this.counts.plan === this.counts.pass + this.counts.fail) {
        this.end();
    }
};

Test.prototype.ok = function (value, name) {
    this.assert({
        type : 'ok',
        ok : !!value,
        name : name,
        found : Boolean(value),
        wanted : true
    });
};

Test.prototype.notOk = function (value, name) {
    this.assert({
        type : 'ok',
        ok : !!!value,
        name : name,
        found : Boolean(value),
        wanted : false
    });
};

Test.prototype.fail = function (value, name) {
    this.assert({
        type : 'fail',
        ok : false,
        name : name,
        found : value,
        wanted : undefined,
        stack : stack()
    });
};

Test.prototype.equal = function (found, wanted, name) {
    this.assert({
        type : 'equal',
        ok : found == wanted,
        name : name,
        found : found,
        wanted : wanted
    });
};

Test.prototype.notEqual = function (found, wanted, name) {
    this.assert({
        type : 'notEqual',
        ok : found != wanted,
        name : name,
        found : found,
        wanted : wanted
    });
};

Test.prototype.deepEqual = function (found, wanted, name) {
    this.assert({
        type : 'deepEqual',
        ok : deepEqual(found, wanted),
        name : name,
        found : found,
        wanted : wanted
    });
};

Test.prototype.notDeepEqual = function (found, wanted, name) {
    this.assert({
        type : 'notDeepEqual',
        ok : !deepEqual(found, wanted),
        name : name,
        found : found,
        wanted : wanted
    });
};

Test.prototype.strictEqual = function (found, wanted, name) {
    this.assert({
        type : 'strictEqual',
        ok : found === wanted,
        name : name,
        found : found,
        wanted : wanted
    });
};

Test.prototype.notStrictEqual = function (found, wanted, name) {
    this.assert({
        type : 'strictEqual',
        ok : found !== wanted,
        name : name,
        found : found,
        wanted : wanted
    });
};

function checkThrows (shouldThrow, fn, expected, name) {
    if (typeof expected === 'string') {
        name = expected;
        expected = null;
    }
    var ok = !shouldThrow, err = undefined;
    
    try { fn() }
    catch (e) {
        ok = !ok;
        err = e;
    }
    
    this.assert({
        type : shouldThrow ? 'throws' : 'doesNotThrow',
        ok : ok,
        found : err,
        expected : expected
    });
}

Test.prototype['throws'] = function (fn, expected, name) {
    checkThrows.call(this, true, fn, expected, name);
};

Test.prototype.doesNotThrow = function (fn, expected, name) {
    checkThrows.call(this, false, fn, expected, name);
};

Test.prototype.ifError = function (err, name) {
    this.assert({
        type : 'ifError',
        ok : !!!err,
        name : name,
        found : err,
        wanted : undefined
    });
};

Test.prototype.plan = function (n) {
    if (this.counts.plan === undefined) {
        this.counts.plan = n;
    }
    else {
        this.counts.plan += n;
    }
    this.push('plan', { testId : this.id, n : n });
};

Test.prototype.log = function (msg) {
    this.push('log', { testId : this.id, message : msg });
};

Test.prototype.end = function () {
    if (this.counts.plan !== undefined
    && this.counts.plan > this.counts.fail + this.counts.pass) {
        this.push('planFail', {
            type : 'fail',
            ok : false,
            found : this.counts.fail + this.counts.pass,
            wanted : this.counts.plan,
            name : 'more tests planned than run',
            testId : this.id
        });
    }
    
    if (!this.ended) {
        this.ended = true;
        this.push('testEnd', { testId : this.id });
        this.emit('testEnd');
    }
};

var jsdom = require('jsdom');
var fs = require('fs');
var emptyHtml = '<html><head></head><body></body></html>';

var jqueryWin = jsdom.jsdom(
    '<html><head><script>'
    + fs.readFileSync(__dirname + '/../vendor/jquery-1.6.min.js', 'utf8')
    + '</script></head><body></body></html>'
).createWindow();

Test.prototype.createWindow = function (url, opts, cb) {
    if (typeof url === 'object') {
        cb = opts;
        opts = url;
        url = opts.url;
    }
    
    if (typeof opts === 'function') {
        cb = opts;
        opts = {};
    }
    if (!opts) opts = {};
    opts.url = url;
    
    var win = createWindow(this, opts, cb);
    this.windows.push(win);
    return win;
};

Test.prototype.submitForm = function (form, params, cb) {
    if (typeof params === 'function') {
        cb = params;
        params = {};
    }
    if (!params) params = {};
    
    if (form[0]) {
        if (form[0] instanceof jsdom.defaultLevel.HTMLFormElement
        || form[0].elements) {
            form = form[0];
        }
    }
    
    if (!form.elements) {
        this.fail('encountered a non-form element');
        return;
    }
    
    var pairs = [];
    
    var len = 0;
    for (var i = 0; i < form.elements.length; i++) {
        if (form.elements[i].name) {
            len += form.elements[i].name.length
                + 1 + form.elements[i].value.length;
            pairs.push(
                escape(form.elements[i].name)
                + '='
                + escape(form.elements[i].value)
            );
        }
    }
    
    var data = pairs.join('&');
    var pwin = form.ownerDocument.parentWindow;
    
    var opts = {
        url : form.action || pwin.location.href.split('?')[0],
        method : form.method || 'GET',
        data : data,
        headers : params.headers || {}
    };
    
    if (!opts.url.match(/^https?:/)) {
        opts.url = pwin.location.protocol + '//' + pwin.location.host
            + path.resolve(path.dirname(pwin.location.path), opts.url)
        ;
    }
    
    if (opts.method === 'POST') {
        if (!opts.headers['content-length']
        && opts.headers['transfer-encoding'] !== 'chunked') {
            opts.headers['content-length'] = len + 1;
        }
    }
    
    var win = createWindow(this, opts, cb);
    this.windows.push(win);
    return win;
};

function createWindow (self, opts, cb) {
    if (opts.url && !opts.host) {
        var u = url.parse(opts.url);
        opts.path = u.pathname + (u.search || '');
        opts.host = u.hostname;
        opts.port = u.port || (u.proto === 'https' ? 443 : 80);
    }
    if (!opts.headers) opts.headers = {};
    opts.method = (opts.method || 'GET').toUpperCase();
    
    if (opts.data) {
        if (opts.method === 'GET') {
            opts.path = opts.path.split('?')[0] + '?' + opts.data;
        }
        else if (opts.method === 'POST') {
            if (!opts.headers['content-length']
            && opts.headers['transfer-encoding'] !== 'chunked') {
                opts.headers['content-length'] = opts.data.length;
            }
        }
    }
    
    if (!opts.url) {
        opts.url = (opts.proto.replace(/:\/*$/, '') || 'http')
            + opts.host + (opts.port ? ':' + opts.port : '')
            + (opts.path || '/')
        ;
    }
    
    var doc = jsdom.jsdom(emptyHtml, '3', {
        deferClose : true,
        url : opts.url
    });
    
    var win = doc.createWindow();
    
    win.addEventListener('load', function () {
        var ts = doc.getElementsByTagName('title');
        if (ts.length) doc.title = ts[0] && ts[0].textContent || '';
        
        try {
            cb(win, function (x, y) {
                return y === undefined
                    ? jqueryWin.$(x, doc)
                    : jqueryWin.$(x, y)
            });
        }
        catch (err) {
            self.assert({
                type : 'error',
                error : err
            });
            self.end();
        }
    });
    
    var req = http.request(opts, function (res) {
        res.on('data', function (buf) {
            doc.write(buf.toString());
        });
        
        res.on('end', function () {
            doc.close();
        });
    });
    
    if (opts.method === 'POST' && opts.data) {
        req.write(opts.data + '\r\n');
    }
    req.end();
    
    return win;
}

function stack () {
    var lines = new Error().stack.split('\n').slice(4,-4);
    return lines.join('\n');
}

});

require.define("http", function (require, module, exports, __dirname, __filename) {
module.exports = require("http-browserify")
});

require.define("/node_modules/http-browserify/package.json", function (require, module, exports, __dirname, __filename) {
module.exports = {"main":"index.js","browserify":"index.js"}
});

require.define("/node_modules/http-browserify/index.js", function (require, module, exports, __dirname, __filename) {
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');

http.request = function (params, cb) {
    if (!params) params = {};
    if (!params.host) params.host = window.location.host.split(':')[0];
    if (!params.port) params.port = window.location.port;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

});

require.define("events", function (require, module, exports, __dirname, __filename) {
if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.toString.call(xs) === '[object Array]'
    }
;

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = list.indexOf(listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

});

require.define("/node_modules/http-browserify/lib/request.js", function (require, module, exports, __dirname, __filename) {
var EventEmitter = require('events').EventEmitter;
var Response = require('./response');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.xhr = xhr;
    self.body = '';
    
    var uri = params.host + ':' + params.port + (params.path || '/');
    
    xhr.open(
        params.method || 'GET',
        (params.scheme || 'http') + '://' + uri,
        true
    );
    
    if (params.headers) {
        Object.keys(params.headers).forEach(function (key) {
            if (!self.isSafeRequestHeader(key)) return;
            var value = params.headers[key];
            if (Array.isArray(value)) {
                value.forEach(function (v) {
                    xhr.setRequestHeader(key, v);
                });
            }
            else xhr.setRequestHeader(key, value)
        });
    }
    
    var res = new Response;
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        res.handle(xhr);
    };
};

Request.prototype = new EventEmitter;

Request.prototype.setHeader = function (key, value) {
    if ((Array.isArray && Array.isArray(value))
    || value instanceof Array) {
        for (var i = 0; i < value.length; i++) {
            this.xhr.setRequestHeader(key, value[i]);
        }
    }
    else {
        this.xhr.setRequestHeader(key, value);
    }
};

Request.prototype.write = function (s) {
    this.body += s;
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.write(s);
    this.xhr.send(this.body);
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return (Request.unsafeHeaders.indexOf(headerName.toLowerCase()) === -1)
};

});

require.define("/node_modules/http-browserify/lib/response.js", function (require, module, exports, __dirname, __filename) {
var EventEmitter = require('events').EventEmitter;

var Response = module.exports = function (res) {
    this.offset = 0;
};

Response.prototype = new EventEmitter;

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
                if ((Array.isArray && Array.isArray(headers[key]))
                || headers[key] instanceof Array) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this.write(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this.write(res);
        
        if (res.error) {
            this.emit('error', res.responseText);
        }
        else this.emit('end');
    }
};

Response.prototype.write = function (res) {
    if (res.responseText.length > this.offset) {
        this.emit('data', res.responseText.slice(this.offset));
        this.offset = res.responseText.length;
    }
};

});

require.define("url", function (require, module, exports, __dirname, __filename) {
var punycode = { encode : function (s) { return s } };

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]+$/,
    // RFC 2396: characters reserved for delimiting URLs.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''],
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // cut off any delimiters.
  // This is to support parse stuff like "<http://foo.com>"
  for (var i = 0, l = rest.length; i < l; i++) {
    if (delims.indexOf(rest.charAt(i)) === -1) break;
  }
  if (i !== 0) rest = rest.substr(i);


  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = rest.indexOf('@');
    if (atSign !== -1) {
      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        var index = rest.indexOf(nonAuthChars[i]);
        if (index !== -1 && index < atSign) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }
      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = rest.substr(0, atSign);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = rest.indexOf(nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = Object.keys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = out.hostname.split('.');
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
      var s = domainArray[i];
      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
          'xn--' + punycode.encode(s) : s);
    }
    out.hostname = newOut.join('.');

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }

    // Now make sure that delims never appear in a url.
    var chop = rest.length;
    for (var i = 0, l = delims.length; i < l; i++) {
      var c = rest.indexOf(delims[i]);
      if (c !== -1) {
        chop = Math.min(c, chop);
      }
    }
    rest = rest.substr(0, chop);
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = auth.split('@').join('%40');
    for (var i = 0, l = nonAuthChars.length; i < l; i++) {
      var nAC = nonAuthChars[i];
      auth = auth.split(nAC).join(encodeURIComponent(nAC));
    }
    auth += '@';
  }

  var protocol = obj.protocol || '',
      host = (obj.host !== undefined) ? auth + obj.host :
          obj.hostname !== undefined ? (
              auth + obj.hostname +
              (obj.port ? ':' + obj.port : '')
          ) :
          false,
      pathname = obj.pathname || '',
      query = obj.query &&
              ((typeof obj.query === 'object' &&
                Object.keys(obj.query).length) ?
                 querystring.stringify(obj.query) :
                 '') || '',
      search = obj.search || (query && ('?' + query)) || '',
      hash = obj.hash || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && source.host.indexOf('@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && source.host.indexOf('@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    out.port = port.substr(1);
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

});

require.define("querystring", function (require, module, exports, __dirname, __filename) {
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.toString.call(xs) === '[object Array]'
    }
;

/*!
 * querystring
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Library version.
 */

exports.version = '0.3.1';

/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Cache non-integer test regexp.
 */

var notint = /[^0-9]/;

/**
 * Parse the given query `str`, returning an object.
 *
 * @param {String} str
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};

  function promote(parent, key) {
    if (parent[key].length == 0) return parent[key] = {};
    var t = {};
    for (var i in parent[key]) t[i] = parent[key][i];
    parent[key] = t;
    return t;
  }

  return String(str)
    .split('&')
    .reduce(function(ret, pair){
      try{ 
        pair = decodeURIComponent(pair.replace(/\+/g, ' '));
      } catch(e) {
        // ignore
      }

      var eql = pair.indexOf('=')
        , brace = lastBraceInKey(pair)
        , key = pair.substr(0, brace || eql)
        , val = pair.substr(brace || eql, pair.length)
        , val = val.substr(val.indexOf('=') + 1, val.length)
        , parent = ret;

      // ?foo
      if ('' == key) key = pair, val = '';

      // nested
      if (~key.indexOf(']')) {
        var parts = key.split('[')
          , len = parts.length
          , last = len - 1;

        function parse(parts, parent, key) {
          var part = parts.shift();

          // end
          if (!part) {
            if (isArray(parent[key])) {
              parent[key].push(val);
            } else if ('object' == typeof parent[key]) {
              parent[key] = val;
            } else if ('undefined' == typeof parent[key]) {
              parent[key] = val;
            } else {
              parent[key] = [parent[key], val];
            }
          // array
          } else {
            obj = parent[key] = parent[key] || [];
            if (']' == part) {
              if (isArray(obj)) {
                if ('' != val) obj.push(val);
              } else if ('object' == typeof obj) {
                obj[Object.keys(obj).length] = val;
              } else {
                obj = parent[key] = [parent[key], val];
              }
            // prop
            } else if (~part.indexOf(']')) {
              part = part.substr(0, part.length - 1);
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            // key
            } else {
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            }
          }
        }

        parse(parts, parent, 'base');
      // optimize
      } else {
        if (notint.test(key) && isArray(parent.base)) {
          var t = {};
          for(var k in parent.base) t[k] = parent.base[k];
          parent.base = t;
        }
        set(parent.base, key, val);
      }

      return ret;
    }, {base: {}}).base;
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix;
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[]'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = Object.keys(obj)
    , key;
  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    ret.push(stringify(obj[key], prefix
      ? prefix + '[' + encodeURIComponent(key) + ']'
      : encodeURIComponent(key)));
  }
  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

});

require.define("/node_modules/testling/lib/deep_equal.js", function (require, module, exports, __dirname, __filename) {
// ripped from node's deepEqual implementation in assert

var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

});

require.define("/node_modules/testling/node_modules/jsdom/package.json", function (require, module, exports, __dirname, __filename) {
module.exports = {"main":"./lib/jsdom"}
});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom.js", function (require, module, exports, __dirname, __filename) {

var dom      = exports.dom = require("./jsdom/level3/index").dom,
    features = require('./jsdom/browser/documentfeatures'),
    fs       = require("fs"),
    pkg      = JSON.parse(fs.readFileSync(__dirname + "/../package.json")),
    request  = require('request'),
    URL      = require('url');

var style = require('./jsdom/level2/style');
exports.defaultLevel = dom.level3.html;
exports.browserAugmentation = require("./jsdom/browser/index").browserAugmentation;
exports.windowAugmentation = require("./jsdom/browser/index").windowAugmentation;

// Proxy feature functions to features module.
['availableDocumentFeatures',
 'defaultDocumentFeatures',
 'applyDocumentFeatures'].forEach(function (propName) {
  exports.__defineGetter__(propName, function () {
    return features[propName];
  });
  exports.__defineSetter__(propName, function (val) {
    return features[propName] = val;
  });
});

exports.debugMode = false;

var createWindow = exports.createWindow = require("./jsdom/browser/index").createWindow;

exports.__defineGetter__('version', function() {
  return pkg.version;
});

exports.level = function (level, feature) {
	if(!feature) feature = 'core'
	return require('./jsdom/level' + level + '/' + feature).dom['level' + level][feature]
}

exports.jsdom = function (html, level, options) {

  options = options || {};
  if(typeof level == "string") {
    level = exports.level(level, 'html')
  } else {
    level   = level || exports.defaultLevel;
  }

  if (!options.url) {
    options.url = (module.parent.id === 'jsdom') ?
                  module.parent.parent.filename  :
                  module.parent.filename;
  }

  if (options.features && options.features.QuerySelector) {
    require("./jsdom/selectors/index").applyQuerySelectorPrototype(level);
  }

  var browser = exports.browserAugmentation(level, options),
      doc     = (browser.HTMLDocument)             ?
                 new browser.HTMLDocument(options) :
                 new browser.Document(options);

  features.applyDocumentFeatures(doc, options.features);

  if (typeof html === 'undefined' || html === null) {
    doc.write('<html><head></head><body></body></html>');
  } else {
    doc.write(html + '');
  }

  if (doc.close && !options.deferClose) {
    doc.close();
  }

  // Kept for backwards-compatibility. The window is lazily created when
  // document.parentWindow or document.defaultView is accessed.
  doc.createWindow = function() {
    // Remove ourself
    if (doc.createWindow) {
      delete doc.createWindow;
    }
    return doc.parentWindow;
  };

  return doc;
};

exports.html = function(html, level, options) {
  html += '';

  // TODO: cache a regex and use it here instead
  //       or make the parser handle it
  var htmlLowered = html.toLowerCase();

  // body
  if (!~htmlLowered.indexOf('<body')) {
    html = '<body>' + html + '</body>';
  }

  // html
  if (!~htmlLowered.indexOf('<html')) {
    html = '<html>' + html + '</html>';
  }
  return exports.jsdom(html, level, options);
};

exports.jQueryify = exports.jsdom.jQueryify = function (window /* path [optional], callback */) {

  if (!window || !window.document) { return; }

  var args = Array.prototype.slice.call(arguments),
      callback = (typeof(args[args.length - 1]) === 'function') && args.pop(),
      path,
      jQueryTag = window.document.createElement("script");

  if (args.length > 1 && typeof(args[1] === 'string')) {
    path = args[1];
  }

  var features = window.document.implementation._features;

  window.document.implementation.addFeature('FetchExternalResources', ['script']);
  window.document.implementation.addFeature('ProcessExternalResources', ['script']);
  window.document.implementation.addFeature('MutationEvents', ["1.0"]);
  jQueryTag.src = path || 'http://code.jquery.com/jquery-latest.js';
  window.document.body.appendChild(jQueryTag);

  jQueryTag.onload = function() {
    if (callback) {
      callback(window, window.jQuery);
    }

    window.document.implementation._features = features;
  };

  return window;
};


exports.env = exports.jsdom.env = function() {
  var
  args        = Array.prototype.slice.call(arguments),
  config      = exports.env.processArguments(args),
  callback    = config.done,
  processHTML = function(err, html) {

    html += '';
    if(err) {
      return callback(err);
    }

    config.scripts = config.scripts || [];
    if (typeof config.scripts === 'string') {
      config.scripts = [config.scripts];
    }

    config.src = config.src || [];
    if (typeof config.src === 'string') {
      config.src = [config.src];
    }

    var
    options    = {
      features: config.features || {
        'FetchExternalResources' : false,
        'ProcessExternalResources' : false
      },
      url: config.url
    },
    window     = exports.html(html, null, options).createWindow(),
    features   = window.document.implementation._features,
    docsLoaded = 0,
    totalDocs  = config.scripts.length,
    readyState = null,
    errors     = null;

    if (!window || !window.document) {
      return callback(new Error('JSDOM: a window object could not be created.'));
    }

    if( config.document ) {
      window.document._referrer = config.document.referrer;
      window.document._cookie = config.document.cookie;
    }

    window.document.implementation.addFeature('FetchExternalResources', ['script']);
    window.document.implementation.addFeature('ProcessExternalResources', ['script']);
    window.document.implementation.addFeature('MutationEvents', ['1.0']);

    var scriptComplete = function() {
      docsLoaded++;
      if (docsLoaded >= totalDocs) {
        window.document.implementation._features = features;
        callback(errors, window);
      }
    }

    if (config.scripts.length > 0 || config.src.length > 0) {
      config.scripts.forEach(function(src) {
        var script = window.document.createElement('script');
        script.onload = function() {
          scriptComplete()
        };

        script.onerror = function(e) {
          if (!errors) {
            errors = [];
          }
          errors.push(e.error);
          scriptComplete();
        };

        script.src = src;
        try {
          // project against invalid dom
          // ex: http://www.google.com/foo#bar
          window.document.documentElement.appendChild(script);
        } catch(e) {
          if(!errors) {
            errors=[];
          }
          errors.push(e.error || e.message);
          callback(errors, window);
        }
      });

      config.src.forEach(function(src) {
        var script = window.document.createElement('script');
        script.onload = function() {
          process.nextTick(scriptComplete);
        };

        script.onerror = function(e) {
          if (!errors) {
            errors = [];
          }
          errors.push(e.error || e.message);
          // nextTick so that an exception within scriptComplete won't cause
          // another script onerror (which would be an infinite loop)
          process.nextTick(scriptComplete);
        };

        script.text = src;
        window.document.documentElement.appendChild(script);
        window.document.documentElement.removeChild(script);
      });
    } else {
      callback(errors, window);
    }
  };

  config.html += '';

  // Handle markup
  if (config.html.indexOf("\n") > 0 || config.html.match(/^\W*</)) {
    processHTML(null, config.html);

  // Handle url/file
  } else {
    var url = URL.parse(config.html);
    config.url = config.url || url.href;
    if (url.hostname) {
      request({ uri: url,
                encoding: config.encoding || 'utf8',
                headers: config.headers || {}
              },
              function(err, request, body) {
                processHTML(err, body);
      });
    } else {
      fs.readFile(url.pathname, processHTML);
    }
  }
};

/*
  Since jsdom.env() is a helper for quickly and easily setting up a
  window with scripts and such already loaded into it, the arguments
  should be fairly flexible.  Here are the requirements

  1) collect `html` (url, string, or file on disk)  (STRING)
  2) load `code` into the window (array of scripts) (ARRAY)
  3) callback when resources are `done`             (FUNCTION)
  4) configuration                                  (OBJECT)

  Rules:
  + if there is one argument it had better be an object with atleast
    a `html` and `done` property (other properties are gravy)

  + arguments above are pulled out of the arguments and put into the
    config object that is returned
*/
exports.env.processArguments = function(args) {
  if (!args || !args.length || args.length < 1) {
    throw new Error('No arguments passed to jsdom.env().');
  }

  var
  props = {
    'html'    : true,
    'done'    : true,
    'scripts' : false,
    'config'  : false,
    'url'     : false,  // the URL for location.href if different from html
    'document': false   // HTMLDocument properties
  },
  propKeys = Object.keys(props),
  config = {
    code : []
  },
  l    = args.length
  ;
  if (l === 1) {
    config = args[0];
  } else {
    args.forEach(function(v) {
      var type = typeof v;
      if (!v) {
        return;
      }
      if (type === 'string' || v + '' === v) {
        config.html = v;
      } else if (type === 'object') {
        // Array
        if (v.length && v[0]) {
          config.scripts = v;
        } else {
          // apply missing required properties if appropriate
          propKeys.forEach(function(req) {

            if (typeof v[req] !== 'undefined' &&
                typeof config[req] === 'undefined') {

              config[req] = v[req];
              delete v[req];
            }
          });
          config.config = v;
        }
      } else if (type === 'function') {
        config.done = v;
      }
    });
  }

  propKeys.forEach(function(req) {
    var required = props[req];
    if (required && typeof config[req] === 'undefined') {
      throw new Error("jsdom.env requires a '" + req + "' argument");
    }
  });
  return config;
};

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/level3/index.js", function (require, module, exports, __dirname, __filename) {
module.exports.dom = {
  level3 : {
    core   : require("./core").dom.level3.core,
    xpath  : require("./xpath").xpath,
    events : require("./events").dom.level3.events,
    html   : require("./html").dom.level3.html,
  }
};

module.exports.dom.ls = require('./ls').dom.level3.ls;

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/level3/xpath.js", function (require, module, exports, __dirname, __filename) {
/** Here is yet another implementation of XPath 1.0 in Javascript.
 *
 * My goal was to make it relatively compact, but as I fixed all the axis bugs
 * the axes became more and more complicated. :-(.
 *
 * I have not implemented namespaces or case-sensitive axes for XML yet.
 *
 * How to test it in Chrome: You can make a Chrome extension that replaces
 * the WebKit XPath parser with this one. But it takes a bit of effort to
 * get around isolated world and same-origin restrictions:
 * manifest.json:
    {
      "name": "XPathTest",
      "version": "0.1",
      "content_scripts": [{
        "matches": ["http://localhost/*"],  // or wildcard host
        "js": ["xpath.js", "injection.js"],
        "all_frames": true, "run_at": "document_start"
      }]
    }
 * injection.js:
    // goal: give my xpath object to the website's JS context.
    var script = document.createElement('script');
    script.textContent =
        "document.addEventListener('xpathextend', function(e) {\n" +
        "  console.log('extending document with xpath...');\n" +
        "  e.detail(window);" +
        "});";
    document.documentElement.appendChild(script);
    document.documentElement.removeChild(script);
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);
    document.dispatchEvent(evt);
 */
(function() {
  var core;
  var xpath;
  if ('function' === typeof require) {
    core = require("../level3/core").dom.level3.core;
    xpath = exports;
  } else {
    core = this;
    xpath = {};
  }


  /***************************************************************************
   *                            Tokenization                                 *
   ***************************************************************************/
  /**
   * The XPath lexer is basically a single regular expression, along with
   * some helper functions to pop different types.
   */
  var Stream = xpath.Stream = function Stream(str) {
    this.original = this.str = str;
    this.peeked = null;
    // TODO: not really needed, but supposedly tokenizer also disambiguates
    // a * b vs. node test *
    this.prev = null;  // for debugging
    this.prevprev = null;
  }
  Stream.prototype = {
    peek: function() {
      if (this.peeked) return this.peeked;
      var m = this.re.exec(this.str);
      if (!m) return null;
      this.str = this.str.substr(m[0].length);
      return this.peeked = m[1];
    },
    /** Peek 2 tokens ahead. */
    peek2: function() {
      this.peek();  // make sure this.peeked is set
      var m = this.re.exec(this.str);
      if (!m) return null;
      return m[1];
    },
    pop: function() {
      var r = this.peek();
      this.peeked = null;
      this.prevprev = this.prev;
      this.prev = r;
      return r;
    },
    trypop: function(tokens) {
      var tok = this.peek();
      if (tok === tokens) return this.pop();
      if (Array.isArray(tokens)) {
        for (var i = 0; i < tokens.length; ++i) {
          var t = tokens[i];
          if (t == tok) return this.pop();;
        }
      }
    },
    trypopfuncname: function() {
      var tok = this.peek();
      if (!this.isQnameRe.test(tok))
        return null;
      switch (tok) {
        case 'comment': case 'text': case 'processing-instruction': case 'node':
          return null;
      }
      if ('(' != this.peek2()) return null;
      return this.pop();
    },
    trypopaxisname: function() {
      var tok = this.peek();
      switch (tok) {
        case 'ancestor': case 'ancestor-or-self': case 'attribute':
        case 'child': case 'descendant': case 'descendant-or-self':
        case 'following': case 'following-sibling': case 'namespace':
        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':
          if ('::' == this.peek2()) return this.pop();
      }
      return null;
    },
    trypopnametest: function() {
      var tok = this.peek();
      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();
      return null;
    },
    trypopliteral: function() {
      var tok = this.peek();
      if (null == tok) return null;
      var first = tok.charAt(0);
      var last = tok.charAt(tok.length - 1);
      if ('"' === first && '"' === last ||
          "'" === first && "'" === last) {
        this.pop();
        return tok.substr(1, tok.length - 2);
      }
    },
    trypopnumber: function() {
      var tok = this.peek();
      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());
      else return null;
    },
    trypopvarref: function() {
      var tok = this.peek();
      if (null == tok) return null;
      if ('$' === tok.charAt(0)) return this.pop().substr(1);
      else return null;
    },
    position: function() {
      return this.original.length - this.str.length;
    }
  };
  (function() {
    // http://www.w3.org/TR/REC-xml-names/#NT-NCName
    var nameStartCharsExceptColon =
        'A-Z_a-z\xc0-\xd6\xd8-\xf6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF' +
        '\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF' +
        '\uFDF0-\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]
    var nameCharExceptColon = nameStartCharsExceptColon +
        '\\-\\.0-9\xb7\u0300-\u036F\u203F-\u2040';
    var ncNameChars = '[' + nameStartCharsExceptColon +
        '][' + nameCharExceptColon + ']*'
    // http://www.w3.org/TR/REC-xml-names/#NT-QName
    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';
    var otherChars = '\\.\\.|[\\(\\)\\[\\].@,]|::';  // .. must come before [.]
    var operatorChars =
        'and|or|mod|div|' +
        '//|!=|<=|>=|[*/|+\\-=<>]';  // //, !=, <=, >= before individual ones.
    var literal = '"[^"]*"|' + "'[^']*'";
    var numberChars = '[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+';
    var variableReference = '\\$' + qNameChars;
    var nameTestChars = '\\*|' + ncNameChars + ':\\*|' + qNameChars;
    var optionalSpace = '[ \t\r\n]*';  // stricter than regexp \s.
    var nodeType = 'comment|text|processing-instruction|node';
    var re = new RegExp(
        // numberChars before otherChars so that leading-decimal doesn't become .
        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +
        nameTestChars + '|' + operatorChars + '|' + literal + '|' +
        variableReference + ')'
        // operatorName | nodeType | functionName | axisName are lumped into
        // qName for now; we'll check them on pop.
    );
    Stream.prototype.re = re;
    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);
    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');
    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');
  })();

  /***************************************************************************
   *                               Parsing                                   *
   ***************************************************************************/
  var parse = xpath.parse = function parse(stream, a) {
    var r = orExpr(stream,a);
    var x, unparsed = [];
    while (x = stream.pop()) {
      unparsed.push(x);
    }
    if (unparsed.length)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               'Position ' + stream.position() +
                               ': Unparsed tokens: ' + unparsed.join(' '));
    return r;
  }

  /**
   * binaryL  ::= subExpr
   *            | binaryL op subExpr
   * so a op b op c becomes ((a op b) op c)
   */
  function binaryL(subExpr, stream, a, ops) {
    var lhs = subExpr(stream, a);
    if (lhs == null) return null;
    var op;
    while (op = stream.trypop(ops)) {
      var rhs = subExpr(stream, a);
      if (rhs == null)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected something after ' + op);
      lhs = a.node(op, lhs, rhs);
    }
    return lhs;
  }
  /**
   * Too bad this is never used. If they made a ** operator (raise to power),
   ( we would use it.
   * binaryR  ::= subExpr
   *            | subExpr op binaryR
   * so a op b op c becomes (a op (b op c))
   */
  function binaryR(subExpr, stream, a, ops) {
    var lhs = subExpr(stream, a);
    if (lhs == null) return null;
    var op = stream.trypop(ops);
    if (op) {
      var rhs = binaryR(stream, a);
      if (rhs == null)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected something after ' + op);
      return a.node(op, lhs, rhs);
    } else {
      return lhs;// TODO
    }
  }
  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath
   * e.g. a, a/b, //a/b
   */
  function locationPath(stream, a) {
    return absoluteLocationPath(stream, a) ||
           relativeLocationPath(null, stream, a);
  }
  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath
   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath
   */
  function absoluteLocationPath(stream, a) {
    var op = stream.peek();
    if ('/' === op || '//' === op) {
      var lhs = a.node('Root');
      return relativeLocationPath(lhs, stream, a, true);
    } else {
      return null;
    }
  }
  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |
   *                            | AbbreviatedRelativeLocationPath
   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step
   * e.g. p/a, etc.
   */
  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {
    if (null == lhs) {
      lhs = step(stream, a);
      if (null == lhs) return lhs;
    }
    var op;
    while (op = stream.trypop(['/', '//'])) {
      if ('//' === op) {
        lhs = a.node('/', lhs,
                     a.node('Axis', 'descendant-or-self', 'node', undefined));
      }
      var rhs = step(stream, a);
      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;
      else isOnlyRootOk = false;
      if (null == rhs)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected step after ' + op);
      lhs = a.node('/', lhs, rhs);
    }
    return lhs;
  }
  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep
   *  [12] AbbreviatedStep::= '.' | '..'
   * e.g. @href, self::p, p, a[@href], ., ..
   */
  function step(stream, a) {
    var abbrStep = stream.trypop(['.', '..']);
    if ('.' === abbrStep)  // A location step of . is short for self::node().
      return a.node('Axis', 'self', 'node');
    if ('..' === abbrStep)  // A location step of .. is short for parent::node()
      return a.node('Axis', 'parent', 'node');

    var axis = axisSpecifier(stream, a);
    var nodeType = nodeTypeTest(stream, a);
    var nodeName;
    if (null == nodeType) nodeName = nodeNameTest(stream, a);
    if (null == axis && null == nodeType && null == nodeName) return null;
    if (null == nodeType && null == nodeName)
        throw new XPathException(
            XPathException.INVALID_EXPRESSION_ERR,
            'Position ' + stream.position() +
            ': Expected nodeTest after axisSpecifier ' + axis);
    if (null == axis) axis = 'child';
    if (null == nodeType) {
      // When there's only a node name, then the node type is forced to be the
      // principal node type of the axis.
      // see http://www.w3.org/TR/xpath/#dt-principal-node-type
      if ('attribute' === axis) nodeType = 'attribute';
      else if ('namespace' === axis) nodeType = 'namespace';
      else nodeType = 'element';
    }
    var lhs = a.node('Axis', axis, nodeType, nodeName);
    var pred;
    while (null != (pred = predicate(lhs, stream, a))) {
      lhs = pred;
    }
    return lhs;
  }
  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier
   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'
   *                | 'descendant' | 'descendant-or-self' | 'following'
   *                | 'following-sibling' | 'namespace' | 'parent' |
   *                | 'preceding' | 'preceding-sibling' | 'self'
   *  [13] AbbreviatedAxisSpecifier::= '@'?
   */
  function axisSpecifier(stream, a) {
    var attr = stream.trypop('@');
    if (null != attr) return 'attribute';
    var axisName = stream.trypopaxisname();
    if (null != axisName) {
      var coloncolon = stream.trypop('::');
      if (null == coloncolon)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Should not happen. Should be ::.');
      return axisName;
    }
  }
  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'
   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'
   * I've split nodeTypeTest from nodeNameTest for convenience.
   */
  function nodeTypeTest(stream, a) {
    if ('(' !== stream.peek2()) {
      return null;
    }
    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);
    if (null != type) {
      if (null == stream.trypop('('))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Should not happen.');
      var param = undefined;
      if (type == 'processing-instruction') {
        param = stream.trypopliteral();
      }
      if (null == stream.trypop(')'))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected close parens.');
      return type
    }
  }
  function nodeNameTest(stream, a) {
    var name = stream.trypopnametest();
    if (name != null) return name;
    else return null;
  }
  /** [8] Predicate::= '[' PredicateExpr ']'
   *  [9] PredicateExpr::= Expr
   */
  function predicate(lhs, stream, a) {
    if (null == stream.trypop('[')) return null;
    var expr = orExpr(stream, a);
    if (null == expr)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               'Position ' + stream.position() +
                               ': Expected expression after [');
    if (null == stream.trypop(']'))
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               'Position ' + stream.position() +
                               ': Expected ] after expression.');
    return a.node('Predicate', lhs, expr);
  }
  /** [14] Expr::= OrExpr
   */
  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall
   * e.g. $x,  (3+4),  "hi",  32,  f(x)
   */
  function primaryExpr(stream, a) {
    var x = stream.trypopliteral();
    if (null == x)
      x = stream.trypopnumber();
    if (null != x) {
      return x;
    }
    var varRef = stream.trypopvarref();
    if (null != varRef) return a.node('VariableReference', varRef);
    var funCall = functionCall(stream, a);
    if (null != funCall) {
      return funCall;
    }
    if (stream.trypop('(')) {
      var e = orExpr(stream, a);
      if (null == e)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected expression after (.');
      if (null == stream.trypop(')'))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected ) after expression.');
      return e;
    }
    return null;
  }
  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'
   *  [17] Argument::= Expr
   */
  function functionCall(stream, a) {
    var name = stream.trypopfuncname(stream, a);
    if (null == name) return null;
    if (null == stream.trypop('('))
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               'Position ' + stream.position() +
                               ': Expected ( ) after function name.');
    var params = [];
    var first = true;
    while (null == stream.trypop(')')) {
      if (!first && null == stream.trypop(','))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected , between arguments of the function.');
      first = false;
      var param = orExpr(stream, a);
      if (param == null)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected expression as argument of function.');
      params.push(param);
    }
    return a.node('FunctionCall', name, params);
  }

  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr
   */
  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }
  /** [19] PathExpr ::= LocationPath
   *                  | FilterExpr
   *                  | FilterExpr '/' RelativeLocationPath
   *                  | FilterExpr '//' RelativeLocationPath
   * Unlike most other nodes, this one always generates a node because
   * at this point all reverse nodesets must turn into a forward nodeset
   */
  function pathExpr(stream, a) {
    // We have to do FilterExpr before LocationPath because otherwise
    // LocationPath will eat up the name from a function call.
    var filter = filterExpr(stream, a);
    if (null == filter) {
      var loc = locationPath(stream, a);
      if (null == loc) {
        throw new Error
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': The expression shouldn\'t be empty...');
      }
      return a.node('PathExpr', loc);
    }
    var rel = relativeLocationPath(filter, stream, a, false);
    if (filter === rel) return rel;
    else return a.node('PathExpr', rel);
  }
  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate
   * aka. FilterExpr ::= PrimaryExpr Predicate*
   */
  function filterExpr(stream, a) {
    var primary = primaryExpr(stream, a);
    if (primary == null) return null;
    var pred, lhs = primary;
    while (null != (pred = predicate(lhs, stream, a))) {
      lhs = pred;
    }
    return lhs;
  }

  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr
   */
  function orExpr(stream, a) {
    var orig = (stream.peeked || '') + stream.str
    var r = binaryL(andExpr, stream, a, 'or');
    var now = (stream.peeked || '') + stream.str;
    return r;
  }
  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr
   */
  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }
  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr
   *                     | EqualityExpr '!=' RelationalExpr
   */
  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }
  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr
   *                       | RelationalExpr '>' AdditiveExpr
   *                       | RelationalExpr '<=' AdditiveExpr
   *                       | RelationalExpr '>=' AdditiveExpr
   */
  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }
  /** [25] AdditiveExpr::= MultiplicativeExpr
   *                     | AdditiveExpr '+' MultiplicativeExpr
   *                     | AdditiveExpr '-' MultiplicativeExpr
   */
  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }
  /** [26] MultiplicativeExpr::= UnaryExpr
   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr
   *                           | MultiplicativeExpr 'div' UnaryExpr
   *                           | MultiplicativeExpr 'mod' UnaryExpr
   */
  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }
  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr
   */
  function unaryExpr(stream, a) {
    if (stream.trypop('-')) {
      var e = unaryExpr(stream, a);
      if (null == e)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Expected unary expression after -');
      return a.node('UnaryMinus', e);
    }
    else return unionExpr(stream, a);
  }
  var astFactory = {
    node: function() {return Array.prototype.slice.call(arguments);}
  };


  /***************************************************************************
   *                            Optimizations (TODO)                         *
   ***************************************************************************/
  /**
   * Some things I've been considering:
   * 1) a//b becomes a/descendant::b if there's no predicate that uses
   *    position() or last()
   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per
   *    node in the node-set rather than once per (node, position, last).
   * For more optimizations, look up Gecko's optimizer:
   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp
   */
  // TODO
  function optimize(ast) {
  }

  /***************************************************************************
   *                           Evaluation: axes                              *
   ***************************************************************************/

  /**
   * Data types: For string, number, boolean, we just use Javascript types.
   * Node-sets have the form
   *    {nodes: [node, ...]}
   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}
   *
   * Most of the time, only the node is used and the position information is
   * discarded. But if you use a predicate, we need to try every value of
   * position and last in case the predicate calls position() or last().
   */

  /**
   * The NodeMultiSet is a helper class to help generate
   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the
   * descendant, descendant-or-self, following-sibling, and
   * preceding-sibling axes for which we can use a stack to organize things.
   */
  function NodeMultiSet(isReverseAxis) {
    this.nodes = [];
    this.pos = [];
    this.lasts = [];
    this.nextPos = [];
    this.seriesIndexes = [];  // index within nodes that each series begins.
    this.isReverseAxis = isReverseAxis;
    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;
  }
  NodeMultiSet.prototype = {
    pushSeries: function pushSeries() {
      this.nextPos.push(1);
      this.seriesIndexes.push(this.nodes.length);
    },
    popSeries: function popSeries() {
      console.assert(0 < this.nextPos.length, this.nextPos);
      var last = this.nextPos.pop() - 1,
          indexInPos = this.nextPos.length,
          seriesBeginIndex = this.seriesIndexes.pop(),
          seriesEndIndex = this.nodes.length;
      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {
        console.assert(indexInPos < this.lasts[i].length);
        console.assert(undefined === this.lasts[i][indexInPos]);
        this.lasts[i][indexInPos] = last;
      }
    },
    finalize: function() {
      if (null == this.nextPos) return this;
      console.assert(0 === this.nextPos.length);
      for (var i = 0; i < this.lasts.length; ++i) {
        for (var j = 0; j < this.lasts[i].length; ++j) {
          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + JSON.stringify(this.lasts));
        }
      }
      this.pushSeries = this.popSeries = this.addNode = function() {
        throw new Error('Already finalized.');
      };
      return this;
    },
    addNode: function addNode(node) {
      console.assert(node);
      this._pushToNodes.call(this.nodes, node)
      this._pushToNodes.call(this.pos, this.nextPos.slice());
      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));
      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;
    },
    simplify: function() {
      this.finalize();
      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};
    }
  };
  function eachContext(nodeMultiSet) {
    var r = [];
    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {
      var node = nodeMultiSet.nodes[i];
      if (!nodeMultiSet.pos) {
        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});
      } else {
        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {
          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});
        }
      }
    }
    return r;
  }
  /** Matcher used in the axes.
   */
  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {
    this.nodeTypeNum = nodeTypeNum;
    this.nodeName = nodeName;
    this.shouldLowerCase = shouldLowerCase;
    this.nodeNameTest =
      null == nodeName ? this._alwaysTrue :
      shouldLowerCase ? this._nodeNameLowerCaseEquals :
      this._nodeNameEquals;
  }
  NodeMatcher.prototype = {
    matches: function matches(node) {
      return (0 === this.nodeTypeNum || node.nodeType === this.nodeTypeNum) &&
          this.nodeNameTest(node.nodeName);
    },
    _alwaysTrue: function(name) {return true;},
    _nodeNameEquals: function _nodeNameEquals(name) {
      return this.nodeName === name;
    },
    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {
      return this.nodeName === name.toLowerCase();
    }
  };

  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var nodeMultiSet = new NodeMultiSet(isReverseAxis);
    while (0 < nodeList.length) {  // can be if for following, preceding
      var node = shift.call(nodeList);
      console.assert(node != null);
      node = followingNode(node);
      nodeMultiSet.pushSeries();
      var numPushed = 1;
      while (null != node) {
        if (! andSelf && matcher.matches(node))
          nodeMultiSet.addNode(node);
        if (node === peek.call(nodeList)) {
          shift.call(nodeList);
          nodeMultiSet.pushSeries();
          numPushed++;
        }
        if (andSelf && matcher.matches(node))
          nodeMultiSet.addNode(node);
        node = followingNode(node);
      }
      while (0 < numPushed--)
        nodeMultiSet.popSeries();
    }
    return nodeMultiSet;
  }

  /** Returns the next non-descendant node in document order.
   * This is the first node in following::node(), if node is the context.
   */
  function followingNonDescendantNode(node) {
    if (node.ownerElement) {
      if (node.ownerElement.firstChild)
        return node.ownerElement.firstChild;
      node = node.ownerElement;
    }
    do {
      if (node.nextSibling) return node.nextSibling;
    } while (node = node.parentNode);
    return null;
  }

  /** Returns the next node in a document-order depth-first search.
   * See the definition of document order[1]:
   *   1) element
   *   2) namespace nodes
   *   3) attributes
   *   4) children
   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order
   */
  function followingNode(node) {
    if (node.ownerElement)  // attributes: following node of element.
      node = node.ownerElement;
    if (null != node.firstChild)
      return node.firstChild;
    do {
      if (null != node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    } while (node);
    return null;
  }
  /** Returns the previous node in document order (excluding attributes
   * and namespace nodes).
   */
  function precedingNode(node) {
    if (node.ownerElement)
      return node.ownerElement;
    if (null != node.previousSibling) {
      node = node.previousSibling;
      while (null != node.lastChild) {
        node = node.lastChild;
      }
      return node;
    }
    if (null != node.parentNode) {
      return node.parentNode;
    }
    return null;
  }
  /** This axis is inefficient if there are many nodes in the nodeList.
   * But I think it's a pretty useless axis so it's ok. */
  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var nodeMultiSet = new NodeMultiSet(false);
    var cursor = nodeList[0];
    var unorderedFollowingStarts = [];
    for (var i = 0; i < nodeList.length; i++) {
      var node = nodeList[i];
      var start = followingNonDescendantNode(node);
      if (start)
        unorderedFollowingStarts.push(start);
    }
    if (0 === unorderedFollowingStarts.length)
      return {nodes:[]};
    var pos = [], nextPos = [];
    var started = 0;
    while (cursor = followingNode(cursor)) {
      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){
        if (cursor === unorderedFollowingStarts[i]) {
          nodeMultiSet.pushSeries();
          unorderedFollowingStarts.splice(i,i+1);
          started++;
        }
      }
      if (started && matcher.matches(cursor)) {
        nodeMultiSet.addNode(cursor);
      }
    }
    console.assert(0 === unorderedFollowingStarts.length);
    for (var i = 0; i < started; i++)
      nodeMultiSet.popSeries();
    return nodeMultiSet.finalize();
  }
  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var cursor = nodeList.pop();
    if (null == cursor) return {nodes:{}};
    var r = {nodes:[], pos:[], lasts:[]};
    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];
    while (cursor = precedingNode(cursor)) {
      if (cursor === nodeList[nodeList.length - 1]) {
        nextParents.push(nodeList.pop());
        nextPos.push(1);
      }
      var matches = matcher.matches(cursor);
      var pos, someoneUsed = false;
      if (matches)
        pos = nextPos.slice();

      for (var i = 0; i < nextParents.length; ++i) {
        if (cursor === nextParents[i]) {
          nextParents[i] = cursor.parentNode || cursor.ownerElement;
          if (matches) {
            pos[i] = null;
          }
        } else {
          if (matches) {
            pos[i] = nextPos[i]++;
            someoneUsed = true;
          }
        }
      }
      if (someoneUsed) {
        r.nodes.unshift(cursor);
        r.pos.unshift(pos);
      }
    }
    for (var i = 0; i < r.pos.length; ++i) {
      var lasts = [];
      r.lasts.push(lasts);
      for (var j = r.pos[i].length - 1; j >= 0; j--) {
        if (null == r.pos[i][j]) {
          r.pos[i].splice(j, j+1);
        } else {
          lasts.unshift(nextPos[j] - 1);
        }
      }
    }
    return r;
  }

  /** node-set, axis -> node-set */
  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {
    while (0 < remaining.length && null != remaining[0].ownerElement) {
      var attr = remaining.shift();
      if (andSelf && matcher.matches(attr)) {
        attrNodes.push(attr);
        attrIndices.push(nodeMultiSet.nodes.length);
      }
    }
    if (null != node && !andSelf) {
      if (matcher.matches(node))
        nodeMultiSet.addNode(node);
    }
    var pushed = false;
    if (null == node) {
      if (0 === remaining.length) return;
      node = remaining.shift();
      nodeMultiSet.pushSeries();
      pushed = true;
    } else if (0 < remaining.length && node === remaining[0]) {
      nodeMultiSet.pushSeries();
      pushed = true;
      remaining.shift();
    }
    if (andSelf) {
      if (matcher.matches(node))
        nodeMultiSet.addNode(node);
    }
    // TODO: use optimization. Also try element.getElementsByTagName
    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;
    var nodeList = node.childNodes;
    for (var j = 0; j < nodeList.length; ++j) {
      var child = nodeList[j];
      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);
    }
    if (pushed) {
      nodeMultiSet.popSeries();
    }
  }
  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var nodeMultiSet = new NodeMultiSet(false);
    var attrIndices = [], attrNodes = [];
    while (0 < nodeList.length) {
      // var node = nodeList.shift();
      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);
    }
    nodeMultiSet.finalize();
    for (var i = attrNodes.length-1; i >= 0; --i) {
      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);
      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);
      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);
    }
    return nodeMultiSet;
  }
  /**
   */
  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var ancestors = []; // array of non-empty arrays of matching ancestors
    for (var i = 0; i < nodeList.length; ++i) {
      var node = nodeList[i];
      var isFirst = true;
      var a = [];
      while (null != node) {
        if (!isFirst || andSelf) {
          if (matcher.matches(node))
            a.push(node);
        }
        isFirst = false;
        node = node.parentNode || node.ownerElement;
      }
      if (0 < a.length)
        ancestors.push(a);
    }
    var lasts = [];
    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);
    var nodeMultiSet = new NodeMultiSet(true);
    var newCtx = {nodes:[], pos:[], lasts:[]};
    while (0 < ancestors.length) {
      var pos = [ancestors[0].length];
      var last = [lasts[0]];
      var node = ancestors[0].pop();
      for (var i = ancestors.length - 1; i > 0; --i) {
        if (node === ancestors[i][ancestors[i].length - 1]) {
          pos.push(ancestors[i].length);
          last.push(lasts[i]);
          ancestors[i].pop();
          if (0 === ancestors[i].length) {
            ancestors.splice(i, i+1);
            lasts.splice(i, i+1);
          }
        }
      }
      if (0 === ancestors[0].length) {
        ancestors.shift();
        lasts.shift();
      }
      newCtx.nodes.push(node);
      newCtx.pos.push(pos);
      newCtx.lasts.push(last);
    }
    return newCtx;
  }
  /** Helper function for sortDocumentOrder. Returns a list of indices, from the
   * node to the root, of positions within parent.
   * For convenience, the node is the first element of the array.
   */
  function addressVector(node) {
    var r = [node];
    if (null != node.ownerElement) {
      node = node.ownerElement;
      r.push(-1);
    }
    while (null != node) {
      var i = 0;
      while (null != node.previousSibling) {
        node = node.previousSibling;
        i++;
      }
      r.push(i);
      node = node.parentNode
    }
    return r;
  }
  function addressComparator(a, b) {
    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node
        alen = a.length,
        blen = b.length;
    if (a[0] === b[0]) return 0;
    var c;
    for (var i = 0; i < minlen; ++i) {
      c = a[alen - i - 1] - b[blen - i - 1];
      if (0 !== c)
        break;
    }
    if (null == c || 0 === c) {
      // All equal until one of the nodes. The longer one is the descendant.
      c = alen - blen;
    }
    if (0 === c)
      c = a.nodeName - b.nodeName;
    if (0 === c)
      c = 1;
    return c;
  }
  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {
    var a = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var v = addressVector(node);
      a.push(v);
    }
    a.sort(addressComparator);
    var b = [];
    for (var i = 0; i < a.length; i++) {
      if (0 < i && a[i][0] === a[i - 1][0])
        continue;
      b.push(a[i][0]);
    }
    return b;
  }
  /** Sort node multiset. Does not do any de-duping. */
  function sortNodeMultiSet(nodeMultiSet) {
    var a = [];
    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {
      var v = addressVector(nodeMultiSet.nodes[i]);
      a.push({v:v, n:nodeMultiSet.nodes[i],
              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});
    }
    a.sort(compare);
    var r = {nodes:[], pos:[], lasts:[]};
    for (var i = 0; i < a.length; ++i) {
      r.nodes.push(a[i].n);
      r.pos.push(a[i].p);
      r.lasts.push(a[i].l);
    }
    function compare(x, y) {
      return addressComparator(x.v, y.v);
    }
    return r;
  }
  /** Returns an array containing all the ancestors down to a node.
   * The array starts with document.
   */
  function nodeAndAncestors(node) {
    var ancestors = [node];
    var p = node;
    while (p = p.parentNode || p.ownerElement) {
      ancestors.unshift(p);
    }
    return ancestors;
  }
  function compareSiblings(a, b) {
    if (a === b) return 0;
    var c = a;
    while (c = c.previousSibling) {
      if (c === b)
        return 1;  // b < a
    }
    c = b;
    while (c = c.previousSibling) {
      if (c === a)
        return -1;  // a < b
    }
    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));
  }
  /** The merge in merge-sort.*/
  function mergeNodeLists(x, y) {
    var a, b, aanc, banc, r = [];
    if ('object' !== typeof x)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               'Invalid LHS for | operator ' +
                               '(expected node-set): ' + x);
    if ('object' !== typeof y)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               'Invalid LHS for | operator ' +
                               '(expected node-set): ' + y);
    while (true) {
      if (null == a) {
        a = x.shift();
        if (null != a)
          aanc = addressVector(a);
      }
      if (null == b) {
        b = y.shift();
        if (null != b)
          banc = addressVector(b);
      }
      if (null == a || null == b) break;
      var c = addressComparator(aanc, banc);
      if (c < 0) {
        r.push(a);
        a = null;
        aanc = null;
      } else if (c > 0) {
        r.push(b);
        b = null;
        banc = null;
      } else if (a.nodeName < b.nodeName) {  // attributes
        r.push(a);
        a = null;
        aanc = null;
      } else if (a.nodeName > b.nodeName) {  // attributes
        r.push(b);
        b = null;
        banc = null;
      } else if (a !== b) {
        // choose b arbitrarily
        r.push(b);
        b = null;
        banc = null;
      } else {
        console.assert(a === b, c);
        // just skip b without pushing it.
        b = null;
        banc = null;
      }
    }
    while (a) {
      r.push(a);
      a = x.shift();
    }
    while (b) {
      r.push(b);
      b = y.shift();
    }
    return r;
  }
  function comparisonHelper(test, x, y, isNumericComparison) {
    var coersion;
    if (isNumericComparison)
      coersion = fn.number;
    else coersion =
      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :
      'number' === typeof x || 'number' === typeof y ? fn.number :
      fn.string;
    if ('object' === typeof x && 'object' === typeof y) {
      var aMap = {};
      for (var i = 0; i < x.nodes.length; ++i) {
        var xi = coersion({nodes:[x.nodes[i]]});
        for (var j = 0; j < y.nodes.length; ++j) {
          var yj = coersion({nodes:[y.nodes[j]]});
          if (test(xi, yj)) return true;
        }
      }
      return false;
    } else if ('object' === typeof x && x.nodes && x.nodes.length) {
      for (var i = 0; i < x.nodes.length; ++i) {
        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);
        if (test(xi, yc))
          return true;
      }
      return false;
    } else if ('object' === typeof y && x.nodes && x.nodes.length) {
      for (var i = 0; i < x.nodes.length; ++i) {
        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);
        if (test(xc, yi))
          return true;
      }
      return false;
    } else {
      var xc = coersion(x), yc = coersion(y);
      return test(xc, yc);
    }
  }
  var axes = xpath.axes = {
    'ancestor':
      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return ancestorHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);
      },
    'ancestor-or-self':
      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return ancestorHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);
      },
    'attribute':
      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        // TODO: figure out whether positions should be undefined here.
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        var nodeMultiSet = new NodeMultiSet(false);
        if (null != nodeName) {
          // TODO: with namespace
          for (var i = 0; i < nodeList.length; ++i) {
            var node = nodeList[i];
            if (null == node.getAttributeNode)
              continue;  // only Element has .getAttributeNode
            var attr = node.getAttributeNode(nodeName);
            if (null != attr && matcher.matches(attr)) {
              nodeMultiSet.pushSeries();
              nodeMultiSet.addNode(attr);
              nodeMultiSet.popSeries();
            }
          }
        } else {
          for (var i = 0; i < nodeList.length; ++i) {
            var node = nodeList[i];
            if (null != node.attributes) {
              nodeMultiSet.pushSeries();
              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes
                var attr = node.attributes[j];
                if (matcher.matches(attr))  // TODO: I think this check is unnecessary
                  nodeMultiSet.addNode(attr);
              }
              nodeMultiSet.popSeries();
            }
          }
        }
        return nodeMultiSet.finalize();
      },
    'child':
      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        var nodeMultiSet = new NodeMultiSet(false);
        for (var i = 0; i < nodeList.length; ++i) {
          var n = nodeList[i];
          if (n.ownerElement)  // skip attribute nodes' text child.
            continue;
          if (n.childNodes) {
            nodeMultiSet.pushSeries();
            var childList = 1 === nodeTypeNum && null != n.children ?
                n.children : n.childNodes;
            for (var j = 0; j < childList.length; ++j) {
              var child = childList[j];
              if (matcher.matches(child)) {
                nodeMultiSet.addNode(child);
              }
              // don't have to do de-duping because children have parent,
              // which are current context.
            }
            nodeMultiSet.popSeries();
          }
        }
        nodeMultiSet.finalize();
        r = sortNodeMultiSet(nodeMultiSet);
        return r;
      },
    'descendant':
      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return descenantHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);
      },
    'descendant-or-self':
      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return descenantHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);
      },
    'following':
      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);
      },
    'following-sibling':
      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return followingSiblingHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,
          Array.prototype.shift, function() {return this[0];},
          function(node) {return node.nextSibling;});
      },
    'namespace':
      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        // TODO
      },
    'parent':
      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        var nodes = [], pos = [];
        for (var i = 0; i < nodeList.length; ++i) {
          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;
          if (null == parent)
            continue;
          if (!matcher.matches(parent))
            continue;
          if (nodes.length > 0 && parent === nodes[nodes.length-1])
            continue;
          nodes.push(parent);
          pos.push([1]);
        }
        return {nodes:nodes, pos:pos, lasts:pos};
      },
    'preceding':
      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return precedingHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);
      },
    'preceding-sibling':
      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return followingSiblingHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,
          Array.prototype.pop, function() {return this[this.length-1];},
          function(node) {return node.previousSibling},
          false, true);
      },
    'self':
      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        var nodes = [], pos = [];
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        for (var i = 0; i < nodeList.length; ++i) {
          if (matcher.matches(nodeList[i])) {
            nodes.push(nodeList[i]);
            pos.push([1]);
          }
        }
        return {nodes: nodes, pos: pos, lasts: pos}
      }
  };

  /***************************************************************************
   *                         Evaluation: functions                           *
   ***************************************************************************/
  var fn = {
    'number': function number(optObject) {
      if ('number' === typeof optObject)
        return optObject;
      if ('string' === typeof optObject)
        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.
      if ('boolean' === typeof optObject)
        return +optObject;
      return fn.number(fn.string.call(this, optObject));  // for node-sets
    },
    'string': function string(optObject) {
      if (null == optObject)
        return fn.string(this);
      if ('string' === typeof optObject || 'boolean' === typeof optObject ||
          'number' === typeof optObject)
        return '' + optObject;
      if (0 == optObject.nodes.length) return '';
      if (null != optObject.nodes[0].textContent)
        return optObject.nodes[0].textContent;
      return optObject.nodes[0].nodeValue;
    },
    'boolean': function booleanVal(x) {
      return 'object' === typeof x ? x.nodes.length > 0 : !!x;
    },
    'last': function last() {
      console.assert(Array.isArray(this.pos));
      console.assert(Array.isArray(this.lasts));
      console.assert(1 === this.pos.length);
      console.assert(1 === this.lasts.length);
      console.assert(1 === this.lasts[0].length);
      return this.lasts[0][0];
    },
    'position': function position() {
      console.assert(Array.isArray(this.pos));
      console.assert(Array.isArray(this.lasts));
      console.assert(1 === this.pos.length);
      console.assert(1 === this.lasts.length);
      console.assert(1 === this.pos[0].length);
      return this.pos[0][0];
    },
    'count': function count(nodeSet) {
      if ('object' !== typeof nodeSet)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Position ' + stream.position() +
                                 ': Function count(node-set) ' +
                                 'got wrong argument type: ' + nodeSet);
      return nodeSet.nodes.length;
    },
    'id': function id(object) {
      var r = {nodes: []};
      var doc = this.nodes[0].ownerDocument || this.nodes[0];
      console.assert(doc);
      var ids;
      if ('object' === typeof object) {
        // for node-sets, map id over each node value.
        ids = [];
        for (var i = 0; i < object.nodes.length; ++i) {
          var idNode = object.nodes[i];
          var idsString = fn.string({nodes:[idNode]});
          var a = idsString.split(/[ \t\r\n]+/g);
          Array.prototype.push.apply(ids, a);
        }
      } else {
        var idsString = fn.string(object);
        var a = idsString.split(/[ \t\r\n]+/g);
        ids = a;
      }
      for (var i = 0; i < ids.length; ++i) {
        var id = ids[i];
        if (0 === id.length)
          continue;
        var node = doc.getElementById(id);
        if (null != node)
          r.nodes.push(node);
      }
      r.nodes = sortUniqDocumentOrder(r.nodes);
      return r;
    },
    'local-name': function(nodeSet) {
      if (null == nodeSet)
        return fn.name(this);
      if (null == nodeSet.nodes) {
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'argument to name() must be a node-set. got ' + nodeSet);
      }
      // TODO: namespaced version
      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml
    },
    'namespace-uri': function(nodeSet) {
      // TODO
      throw new Error('not implemented yet');
    },
    'name': function(nodeSet) {
      if (null == nodeSet)
        return fn.name(this);
      if (null == nodeSet.nodes) {
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'argument to name() must be a node-set. got ' + nodeSet);
      }
      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml
    },
    'concat': function concat(x) {
      var l = [];
      for (var i = 0; i < arguments.length; ++i) {
        l.push(fn.string(arguments[i]));
      }
      return l.join('');
    },
    'starts-with': function startsWith(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      return as.substr(0, bs.length) === bs;
    },
    'contains': function contains(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      var i = as.indexOf(bs);
      if (-1 === i) return false;
      return true;
    },
    'substring-before': function substringBefore(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      var i = as.indexOf(bs);
      if (-1 === i) return '';
      return as.substr(0, i);
    },
    'substring-after': function substringBefore(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      var i = as.indexOf(bs);
      if (-1 === i) return '';
      return as.substr(i + bs.length);
    },
    'substring': function substring(string, start, optEnd) {
      if (null == string || null == start) {
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 'Must be at least 2 arguments to string()');
      }
      var sString = fn.string(string),
          iStart = fn.round(start),
          iEnd = optEnd == null ? null : fn.round(optEnd);
      // Note that xpath string positions user 1-based index
      if (iEnd == null)
        return sString.substr(iStart - 1);
      else
        return sString.substr(iStart - 1, iEnd);
    },
    'string-length': function stringLength(optString) {
      return fn.string.call(this, optString).length;
    },
    'normalize-space': function normalizeSpace(optString) {
      var s = fn.string.call(this, optString);
      return s.replace(/[ \t\r\n]+/g, ' ').replace(/^ | $/g, '');
    },
    'translate': function translate(string, from, to) {
      var sString = fn.string.call(this, string),
          sFrom = fn.string(from),
          sTo = fn.string(to);
      var eachCharRe = [];
      var map = {};
      for (var i = 0; i < sFrom.length; ++i) {
        var c = sFrom.charAt(i);
        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.
        // copied from goog.string.regExpEscape in the Closure library.
        eachCharRe.push(
          c.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
            replace(/\x08/g, '\\x08'));
      }
      var re = new RegExp(eachCharRe.join('|'), 'g');
      return sString.replace(re, function(c) {return map[c];});
    },
    /// Boolean functions
    'not': function not(x) {
      var bx = fn['boolean'](x);
      return !bx;
    },
    'true': function trueVal() { return true; },
    'false': function falseVal() { return false; },
    // TODO
    'lang': function lang(string) { throw new Error('Not implemented');},
    'sum': function sum(optNodeSet) {
      if (null == optNodeSet) return fn.sum(this);
      // for node-sets, map id over each node value.
      var sum = 0;
      for (var i = 0; i < optNodeSet.nodes.length; ++i) {
        var node = optNodeSet.nodes[i];
        var x = fn.number({nodes:[node]});
        sum += x;
      }
      return sum;
    },
    'floor': function floor(number) {
      return Math.floor(fn.number(number));
    },
    'ceiling': function ceiling(number) {
      return Math.ceil(fn.number(number));
    },
    'round': function round(number) {
      return Math.round(fn.number(number));
    }
  };
  /***************************************************************************
   *                         Evaluation: operators                           *
   ***************************************************************************/
  var more = {
    UnaryMinus: function(x) { return -fn.number(x); },
    '+': function(x, y) { return fn.number(x) + fn.number(y); },
    '-': function(x, y) { return fn.number(x) - fn.number(y); },
    '*': function(x, y) { return fn.number(x) * fn.number(y); },
    'div': function(x, y) { return fn.number(x) / fn.number(y); },
    'mod': function(x, y) { return fn.number(x) % fn.number(y); },
    '<': function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);
    },
    '<=': function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);
    },
    '>':  function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);
    },
    '>=': function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);
    },
    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },
    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },
    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },
    '=': function(x, y) {
      // optimization for two node-sets case: avoid n^2 comparisons.
      if ('object' === typeof x && 'object' === typeof y) {
        var aMap = {};
        for (var i = 0; i < x.nodes.length; ++i) {
          var s = fn.string({nodes:[x.nodes[i]]});
          aMap[s] = true;
        }
        for (var i = 0; i < y.nodes.length; ++i) {
          var s = fn.string({nodes:[y.nodes[i]]});
          if (aMap[s]) return true;
        }
        return false;
      } else {
        return comparisonHelper(function(x, y) {return x === y;}, x, y);
      }
    },
    '!=': function(x, y) {
      // optimization for two node-sets case: avoid n^2 comparisons.
      if ('object' === typeof x && 'object' === typeof y) {
        if (0 === x.nodes.length || 0 === y.nodes.length) return false;
        var aMap = {};
        for (var i = 0; i < x.nodes.length; ++i) {
          var s = fn.string({nodes:[x.nodes[i]]});
          aMap[s] = true;
        }
        for (var i = 0; i < y.nodes.length; ++i) {
          var s = fn.string({nodes:[y.nodes[i]]});
          if (!aMap[s]) return true;
        }
        return false;
      } else {
        return comparisonHelper(function(x, y) {return x !== y;}, x, y);
      }
    }
  };
  var nodeTypes = xpath.nodeTypes = {
    'node': 0,
    'attribute': 2,
    'comment': 8, // this.doc.COMMENT_NODE,
    'text': 3, // this.doc.TEXT_NODE,
    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,
    'element': 1  //this.doc.ELEMENT_NODE
  };
  /** For debugging and unit tests: returnjs a stringified version of the
   * argument. */
  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {
    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);
    return JSON.stringify(helper(ctx));

    function helper(ctx) {
      if (Array.isArray(ctx)) {
        return ctx.map(function(x) {return helper(x);});
      }
      if ('object' !== typeof ctx) return ctx;
      if (null == ctx) return ctx;
    //  if (ctx.toString) return ctx.toString();
      if (null != ctx.outerHTML) return ctx.outerHTML;
      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;
      if (ctx[seenKey]) return '[circular]';
      ctx[seenKey] = true;
      var nicer = {};
      for (var key in ctx) {
        if (seenKey === key)
          continue;
        try {
          nicer[key] = helper(ctx[key]);
        } catch (e) {
          nicer[key] = '[exception: ' + e.message + ']';
        }
      }
      delete ctx[seenKey];
      return nicer;
    }
  }
  var Evaluator = xpath.Evaluator = function Evaluator(doc) {
    this.doc = doc;
  }
  Evaluator.prototype = {
    val: function val(ast, ctx) {
      console.assert(ctx.nodes);

      if ('number' === typeof ast || 'string' === typeof ast) return ast;
      if (more[ast[0]]) {
        var evaluatedParams = [];
        for (var i = 1; i < ast.length; ++i) {
          evaluatedParams.push(this.val(ast[i], ctx));
        }
        var r = more[ast[0]].apply(ctx, evaluatedParams);
        return r;
      }
      switch (ast[0]) {
        case 'Root': return {nodes: [this.doc]};
        case 'FunctionCall':
          var functionName = ast[1], functionParams = ast[2];
          if (null == fn[functionName])
            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                     'Unknown function: ' + functionName);
          var evaluatedParams = [];
          for (var i = 0; i < functionParams.length; ++i) {
            evaluatedParams.push(this.val(functionParams[i], ctx));
          }
          var r = fn[functionName].apply(ctx, evaluatedParams);
          return r;
        case 'Predicate':
          var lhs = this.val(ast[1], ctx);
          var ret = {nodes: []};
          var contexts = eachContext(lhs);
          for (var i = 0; i < contexts.length; ++i) {
            var singleNodeSet = contexts[i];
            var rhs = this.val(ast[2], singleNodeSet);
            var success;
            if ('number' === typeof rhs) {
              success = rhs === singleNodeSet.pos[0][0];
            } else {
              success = fn['boolean'](rhs);
            }
            if (success) {
              var node = singleNodeSet.nodes[0];
              ret.nodes.push(node);
              // skip over all the rest of the same node.
              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {
                i++;
              }
            }
          }
          return ret;
        case 'PathExpr':
          // turn the path into an expressoin; i.e., remove the position
          // information of the last axis.
          var x = this.val(ast[1], ctx);
          // Make the nodeset a forward-direction-only one.
          if (x.finalize) {  // it is a NodeMultiSet
            for (var i = 0; i < x.nodes.length; ++i) {
              console.assert(null != x.nodes[i].nodeType);
            }
            return {nodes: x.nodes};
          } else {
            return x;
          }
        case '/':
          // TODO: don't generate '/' nodes, just Axis nodes.
          var lhs = this.val(ast[1], ctx);
          console.assert(null != lhs);
          var r = this.val(ast[2], lhs);
          console.assert(null != r);
          return r;
        case 'Axis':
          // All the axis tests from Step. We only get AxisSpecifier NodeTest,
          // not the predicate (which is applied later)
          var axis = ast[1],
              nodeType = ast[2],
              nodeTypeNum = nodeTypes[nodeType],
              shouldLowerCase = true,  // TODO: give option
              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];
          nodeName = nodeName === '*' ? null : nodeName;
          if ('object' !== typeof ctx) return {nodes:[], pos:[]};
          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?
          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);
          return r;
      }
    }
  };
  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {
    //var astFactory = new AstEvaluatorFactory(doc, context);
    var stream = new Stream(expr);
    var ast = parse(stream, astFactory);
    var val = new Evaluator(doc).val(ast, {nodes: [context]});
    return val;
  }

  /***************************************************************************
   *                           DOM interface                                 *
   ***************************************************************************/
  var XPathException = xpath.XPathException = function XPathException(code, message) {
    var e = new Error(message);
    this.__proto__ = e;
    this.name = 'XPathException';
    this.code = code;
  }
  XPathException.prototype = Error.prototype;
  XPathException.prototype.__proto__ = XPathException;
  XPathException.INVALID_EXPRESSION_ERR = 51;
  XPathException.TYPE_ERR = 52;


  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}
  XPathEvaluator.prototype = {
    createExpression: function(expression, resolver) {
      return new XPathExpression(expression, resolver);
    },
    createNSResolver: function(nodeResolver) {
      // TODO
    },
    evaluate: function evaluate(expression, contextNode, resolver, type, result) {
      var expr = new XPathExpression(expression, resolver);
      return expr.evaluate(contextNode, type, result);
    }
  };


  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {
    var stream = new Stream(expression);
    this._ast = parse(stream, astFactory);
    this._doc = optDoc;
  }
  XPathExpression.prototype = {
    evaluate: function evaluate(contextNode, type, result) {
      if (null == contextNode.nodeType)
        throw new Error('bad argument (expected context node): ' + contextNode);
      var doc = contextNode.ownerDocument || contextNode;
      if (null != this._doc && this._doc !== doc) {
        throw new core.DOMException(
            core.WRONG_DOCUMENT_ERR,
            'The document must be the same as the context node\'s document.');
      }
      var evaluator = new Evaluator(doc);
      var value = evaluator.val(this._ast, {nodes: [contextNode]});
      if (XPathResult.NUMBER_TYPE === type)
        value = fn.number(value);
      else if (XPathResult.STRING_TYPE === type)
        value = fn.string(value);
      else if (XPathResult.BOOLEAN_TYPE === type)
        value = fn['boolean'](value);
      else if (XPathResult.ANY_TYPE !== type &&
               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&
               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&
               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&
               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&
               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&
               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)
        throw new core.DOMException(
            core.NOT_SUPPORTED_ERR,
            'You must provide an XPath result type (0=any).');
      else if (XPathResult.ANY_TYPE !== type &&
               'object' !== typeof value)
        throw new XPathException(
            XPathException.TYPE_ERR,
            'Value should be a node-set: ' + value);
      return new XPathResult(doc, value, type);
    }
  }

  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {
    this._value = value;
    this._resultType = resultType;
    this._i = 0;
    this._invalidated = false;
    if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||
        this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
      doc.addEventListener('DOMSubtreeModified', invalidate, true);
      var self = this;
      function invalidate() {
        self._invalidated = true;
        doc.removeEventListener('DOMSubtreeModified', invalidate, true);
      }
    }
  }
  XPathResult.ANY_TYPE = 0;
  XPathResult.NUMBER_TYPE = 1;
  XPathResult.STRING_TYPE = 2;
  XPathResult.BOOLEAN_TYPE = 3;
  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
  XPathResult.prototype = {
    // XPathResultType
    get resultType() {
      if (this._resultType) return this._resultType;
      switch (typeof this._value) {
        case 'number': return XPathResult.NUMBER_TYPE;
        case 'string': return XPathResult.STRING_TYPE;
        case 'boolean': return XPathResult.BOOLEAN_TYPE;
        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
      }
    },
    get numberValue() {
      if (XPathResult.NUMBER_TYPE !== this.resultType)
        throw new XPathException(XPathException.TYPE_ERR,
                                 'You should have asked for a NUMBER_TYPE.');
      return this._value;
    },
    get stringValue() {
      if (XPathResult.STRING_TYPE !== this.resultType)
        throw new XPathException(XPathException.TYPE_ERR,
                                 'You should have asked for a STRING_TYPE.');
      return this._value;
    },
    get booleanValue() {
      if (XPathResult.BOOLEAN_TYPE !== this.resultType)
        throw new XPathException(XPathException.TYPE_ERR,
                                 'You should have asked for a BOOLEAN_TYPE.');
      return this._value;
    },
    get singleNodeValue() {
      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&
          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');
      return this._value.nodes[0] || null;
    },
    get invalidIteratorState() {
      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&
          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)
        return false;
      return !!this._invalidated;
    },
    get snapshotLength() {
      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');
      return this._value.nodes.length;
    },
    iterateNext: function iterateNext() {
      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&
          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');
      if (this.invalidIteratorState)
        throw new core.DOMException(
            core.INVALID_STATE_ERR,
            'The document has been mutated since the result was returned');
      return this._value.nodes[this._i++] || null;
    },
    snapshotItem: function snapshotItem(index) {
      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');
      return this._value.nodes[index] || null;
    }
  };
  // so you can access ANY_TYPE etc. from the instances:
  XPathResult.prototype.__proto__ = XPathResult;

  core.XPathException = XPathException;
  core.XPathExpression = XPathExpression;
  core.XPathResult = XPathResult;
  core.XPathEvaluator = XPathEvaluator;

  core.Document.prototype.createExpression =
    XPathEvaluator.prototype.createExpression;

  core.Document.prototype.createNSResolver =
      XPathEvaluator.prototype.createNSResolver;

  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;

})();

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/browser/documentfeatures.js", function (require, module, exports, __dirname, __filename) {
exports.availableDocumentFeatures = [
  'FetchExternalResources',
  'ProcessExternalResources',
  'MutationEvents',
  'QuerySelector'
];

exports.defaultDocumentFeatures = {
  "FetchExternalResources"   : ['script'/*, 'img', 'css', 'frame', 'link'*/],
  "ProcessExternalResources" : ['script'/*, 'frame', 'iframe'*/],
  "MutationEvents"           : '2.0',
  "QuerySelector"            : false
};

exports.applyDocumentFeatures = function(doc, features) {
  var i, maxFeatures = exports.availableDocumentFeatures.length,
      defaultFeatures = exports.defaultDocumentFeatures,
      j,
      k,
      featureName,
      featureSource;

  features = features || {};

  for (i=0; i<maxFeatures; i++) {
    featureName = exports.availableDocumentFeatures[i];
    if (typeof features[featureName] !== 'undefined') {
      featureSource = features[featureName];
    // We have to check the lowercase version also because the Document feature
    // methods convert everything to lowercase.
    } else if (typeof features[featureName.toLowerCase()] !== 'undefined') {
      featureSource = features[featureName.toLowerCase()];
    } else if (defaultFeatures[featureName]) {
      featureSource = defaultFeatures[featureName];
    } else {
      continue;
    }

    doc.implementation.removeFeature(featureName);

    if (typeof featureSource !== 'undefined') {
      if (featureSource instanceof Array) {
        k = featureSource.length;
        for (j=0; j<k; j++) {
          doc.implementation.addFeature(featureName, featureSource[j]);
        }
      } else {
        doc.implementation.addFeature(featureName, featureSource);
      }
    }
  }
};

});

require.define("/node_modules/testling/node_modules/request/package.json", function (require, module, exports, __dirname, __filename) {
module.exports = {"main":"./main"}
});

require.define("/node_modules/testling/node_modules/request/main.js", function (require, module, exports, __dirname, __filename) {
// Copyright 2010-2011 Mikeal Rogers
// 
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

var http = require('http')
  , https = false
  , tls = false
  , url = require('url')
  , util = require('util')
  , stream = require('stream')
  , qs = require('querystring')
  , mimetypes = require('./mimetypes')
  ;

try {
  https = require('https')
} catch (e) {}

try {
  tls = require('tls')
} catch (e) {}

function toBase64 (str) {
  return (new Buffer(str || "", "ascii")).toString("base64")
}

// Hacky fix for pre-0.4.4 https
if (https && !https.Agent) {
  https.Agent = function (options) {
    http.Agent.call(this, options)
  }
  util.inherits(https.Agent, http.Agent)
  https.Agent.prototype._getConnection = function(host, port, cb) {
    var s = tls.connect(port, host, this.options, function() {
      // do other checks here?
      if (cb) cb()
    })
    return s
  }
}

function isReadStream (rs) {
  if (rs.readable && rs.path && rs.mode) {
    return true  
  }
}

function copy (obj) {
  var o = {}
  for (i in obj) o[i] = obj[i]
  return o
}

var isUrl = /^https?:/

var globalPool = {}

function Request (options) {
  stream.Stream.call(this)
  this.readable = true
  this.writable = true
  
  if (typeof options === 'string') {
    options = {uri:options}
  }
  
  for (i in options) {
    this[i] = options[i]
  }
  if (!this.pool) this.pool = globalPool
  this.dests = []
  this.__isRequestRequest = true
}
util.inherits(Request, stream.Stream)
Request.prototype.getAgent = function (host, port) {
  if (!this.pool[host+':'+port]) {
    this.pool[host+':'+port] = new this.httpModule.Agent({host:host, port:port})
  }
  return this.pool[host+':'+port]
}
Request.prototype.request = function () {  
  var options = this
  if (options.url) {
    // People use this property instead all the time so why not just support it.
    options.uri = options.url
    delete options.url
  }

  if (!options.uri) {
    throw new Error("options.uri is a required argument")
  } else {
    if (typeof options.uri == "string") options.uri = url.parse(options.uri)
  }
  if (options.proxy) {
    if (typeof options.proxy == 'string') options.proxy = url.parse(options.proxy)
  }

  options._redirectsFollowed = options._redirectsFollowed || 0
  options.maxRedirects = (options.maxRedirects !== undefined) ? options.maxRedirects : 10
  options.followRedirect = (options.followRedirect !== undefined) ? options.followRedirect : true
  
  options.headers = options.headers ? copy(options.headers) : {}

  var setHost = false
  if (!options.headers.host) {
    options.headers.host = options.uri.hostname
    if (options.uri.port) {
      if ( !(options.uri.port === 80 && options.uri.protocol === 'http:') &&
           !(options.uri.port === 443 && options.uri.protocol === 'https:') )
      options.headers.host += (':'+options.uri.port)
    }
    setHost = true
  }

  if (!options.uri.pathname) {options.uri.pathname = '/'}
  if (!options.uri.port) {
    if (options.uri.protocol == 'http:') {options.uri.port = 80}
    else if (options.uri.protocol == 'https:') {options.uri.port = 443}
  }

  if (options.bodyStream || options.responseBodyStream) {
    console.error('options.bodyStream and options.responseBodyStream is deprecated. You should now send the request object to stream.pipe()')
    this.pipe(options.responseBodyStream || options.bodyStream)
  }
  
  if (options.proxy) {
    options.port = options.proxy.port
    options.host = options.proxy.hostname
  } else {
    options.port = options.uri.port
    options.host = options.uri.hostname
  }
  
  if (options.onResponse === true) {
    options.onResponse = options.callback
    delete options.callback
  }
  
  var clientErrorHandler = function (error) {
    if (setHost) delete options.headers.host
    options.emit('error', error)
  }
  if (options.onResponse) options.on('error', function (e) {options.onResponse(e)}) 
  if (options.callback) options.on('error', function (e) {options.callback(e)})
  

  if (options.uri.auth && !options.headers.authorization) {
    options.headers.authorization = "Basic " + toBase64(options.uri.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))
  }
  if (options.proxy && options.proxy.auth && !options.headers['proxy-authorization']) {
    options.headers.authorization = "Basic " + toBase64(options.uri.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))
  }

  options.path = options.uri.href.replace(options.uri.protocol + '//' + options.uri.host, '')
  if (options.path.length === 0) options.path = '/'

  if (options.proxy) options.path = (options.uri.protocol + '//' + options.uri.host + options.path)

  if (options.json) {
    options.headers['content-type'] = 'application/json'
    if (typeof options.json === 'boolean') {
      if (typeof options.body === 'object') options.body = JSON.stringify(options.body)
    } else {
      options.body = JSON.stringify(options.json)
    }
    
  } else if (options.multipart) {
    options.body = ''
    options.headers['content-type'] = 'multipart/related;boundary="frontier"'
    if (!options.multipart.forEach) throw new Error('Argument error, options.multipart.')
    
    options.multipart.forEach(function (part) {
      var body = part.body
      if(!body) throw Error('Body attribute missing in multipart.')
      delete part.body
      options.body += '--frontier\r\n' 
      Object.keys(part).forEach(function(key){
        options.body += key + ': ' + part[key] + '\r\n'
      })
      options.body += '\r\n' + body + '\r\n'
    })
    options.body += '--frontier--'
  }

  if (options.body) {
    if (!Buffer.isBuffer(options.body)) {
      options.body = new Buffer(options.body)
    }
    if (options.body.length) {
      options.headers['content-length'] = options.body.length
    } else {
      throw new Error('Argument error, options.body.')
    }
  }
  
  options.httpModule = 
    {"http:":http, "https:":https}[options.proxy ? options.proxy.protocol : options.uri.protocol]

  if (!options.httpModule) throw new Error("Invalid protocol")
  
  if (options.pool === false) {
    options.agent = false
  } else {
    if (options.maxSockets) {
      // Don't use our pooling if node has the refactored client
      options.agent = options.httpModule.globalAgent || options.getAgent(options.host, options.port)
      options.agent.maxSockets = options.maxSockets
    }
    if (options.pool.maxSockets) {
      // Don't use our pooling if node has the refactored client
      options.agent = options.httpModule.globalAgent || options.getAgent(options.host, options.port)
      options.agent.maxSockets = options.pool.maxSockets
    }
  }
  
  options.start = function () {
    options._started = true
    options.method = options.method || 'GET'
    
    options.req = options.httpModule.request(options, function (response) {
      options.response = response
      response.request = options
      if (setHost) delete options.headers.host
      if (options.timeout && options.timeoutTimer) clearTimeout(options.timeoutTimer)

      if (response.statusCode >= 300 && 
          response.statusCode < 400  && 
          options.followRedirect     && 
          options.method !== 'PUT' && 
          options.method !== 'POST' &&
          response.headers.location) {
        if (options._redirectsFollowed >= options.maxRedirects) {
          options.emit('error', new Error("Exceeded maxRedirects. Probably stuck in a redirect loop."))
          return
        }
        options._redirectsFollowed += 1
        
        if (!isUrl.test(response.headers.location)) {
          response.headers.location = url.resolve(options.uri.href, response.headers.location)
        }
        options.uri = response.headers.location
        delete options.req
        delete options.agent
        delete options._started
        if (options.headers) {
          delete options.headers.host
        }
        request(options, options.callback)
        return // Ignore the rest of the response
      } else {
        options._redirectsFollowed = 0
        // Be a good stream and emit end when the response is finished.
        // Hack to emit end on close because of a core bug that never fires end
        response.on('close', function () {
          if (!options._ended) options.response.emit('end')
        })

        if (options.encoding) {
          if (options.dests.length !== 0) {
            console.error("Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.")
          } else {
            response.setEncoding(options.encoding)
          }
        }

        options.dests.forEach(function (dest) {
          if (dest.headers) {
            dest.headers['content-type'] = response.headers['content-type']
            if (response.headers['content-length']) {
              dest.headers['content-length'] = response.headers['content-length']
            }
          } 
          if (dest.setHeader) {
            for (i in response.headers) {
              dest.setHeader(i, response.headers[i])
            }
            dest.statusCode = response.statusCode
          }
          if (options.pipefilter) options.pipefilter(response, dest)
        })

        response.on("data", function (chunk) {options.emit("data", chunk)})
        response.on("end", function (chunk) {
          options._ended = true 
          options.emit("end", chunk)
        })
        response.on("close", function () {options.emit("close")})

        if (options.onResponse) {
          options.onResponse(null, response)
        }
        if (options.callback) {
          var buffer = ''
          options.on("data", function (chunk) { 
            buffer += chunk 
          })
          options.on("end", function () { 
            response.body = buffer
            if (options.json) {
              try {
                response.body = JSON.parse(response.body)
              } catch (e) {}
            }
            options.callback(null, response, response.body) 
          })  
        }
      }
    })

    if (options.timeout) {
      options.timeoutTimer = setTimeout(function() {
          options.req.abort()
          var e = new Error("ETIMEDOUT")
          e.code = "ETIMEDOUT"
          options.emit("error", e)
      }, options.timeout)
    }

    options.req.on('error', clientErrorHandler)
  }  
    
  options.once('pipe', function (src) {
    if (options.ntick) throw new Error("You cannot pipe to this stream after the first nextTick() after creation of the request stream.")
    options.src = src
    if (isReadStream(src)) {
      if (!options.headers['content-type'] && !options.headers['Content-Type'])
        options.headers['content-type'] = mimetypes.lookup(src.path.slice(src.path.lastIndexOf('.')+1))
    } else {
      if (src.headers) {
        for (i in src.headers) {
          if (!options.headers[i]) {
            options.headers[i] = src.headers[i]
          }
        }
      }
      if (src.method && !options.method) {
        options.method = src.method
      }
    }
    
    options.on('pipe', function () {
      console.error("You have already piped to this stream. Pipeing twice is likely to break the request.")
    })
  })
  
  process.nextTick(function () {
    if (options.body) {
      options.write(options.body)
      options.end()
    } else if (options.requestBodyStream) {
      console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.")
      options.requestBodyStream.pipe(options)
    } else if (!options.src) {
      options.end()
    }
    options.ntick = true
  })
}
Request.prototype.pipe = function (dest) {
  if (this.response) throw new Error("You cannot pipe after the response event.")
  this.dests.push(dest)
  stream.Stream.prototype.pipe.call(this, dest)
  return dest
}
Request.prototype.write = function () {
  if (!this._started) this.start()
  if (!this.req) throw new Error("This request has been piped before http.request() was called.")
  this.req.write.apply(this.req, arguments)
}
Request.prototype.end = function () {
  if (!this._started) this.start()
  if (!this.req) throw new Error("This request has been piped before http.request() was called.")
  this.req.end.apply(this.req, arguments)
}
Request.prototype.pause = function () {
  if (!this.response) throw new Error("This request has been piped before http.request() was called.")
  this.response.pause.apply(this.response, arguments)
}
Request.prototype.resume = function () {
  if (!this.response) throw new Error("This request has been piped before http.request() was called.")
  this.response.resume.apply(this.response, arguments)
}

function request (options, callback) {
  if (typeof options === 'string') options = {uri:options}
  if (callback) options.callback = callback
  var r = new Request(options)
  r.request()
  return r
}

module.exports = request

request.defaults = function (options) {
  var def = function (method) {
    var d = function (opts, callback) {
      if (typeof opts === 'string') opts = {uri:opts}
      for (i in options) {
        if (opts[i] === undefined) opts[i] = options[i]
      }
      return method(opts, callback)
    }
    return d
  }
  de = def(request)
  de.get = def(request.get)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  de.del = def(request.del)
  return de
}

request.get = request
request.post = function (options, callback) {
  if (typeof options === 'string') options = {uri:options}
  options.method = 'POST'
  return request(options, callback)
}
request.put = function (options, callback) {
  if (typeof options === 'string') options = {uri:options}
  options.method = 'PUT'
  return request(options, callback)
}
request.head = function (options, callback) {
  if (typeof options === 'string') options = {uri:options}
  options.method = 'HEAD'
  if (options.body || options.requestBodyStream || options.json || options.multipart) {
    throw new Error("HTTP HEAD requests MUST NOT include a request body.")
  }
  return request(options, callback)
}
request.del = function (options, callback) {
  if (typeof options === 'string') options = {uri:options}
  options.method = 'DELETE'
  return request(options, callback)
}

});

require.define("util", function (require, module, exports, __dirname, __filename) {
var events = require('events');

exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

});

require.define("stream", function (require, module, exports, __dirname, __filename) {
var events = require('events');
var util = require('util');

function Stream() {
  events.EventEmitter.call(this);
}
util.inherits(Stream, events.EventEmitter);
module.exports = Stream;
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once, and
  // only when all sources have ended.
  if (!dest._isStdio && (!options || options.end !== false)) {
    dest._pipeCount = dest._pipeCount || 0;
    dest._pipeCount++;

    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (this.listeners('error').length === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('end', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('end', cleanup);
  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

});

require.define("/node_modules/testling/node_modules/request/mimetypes.js", function (require, module, exports, __dirname, __filename) {
// from http://github.com/felixge/node-paperboy
exports.types = {
  "aiff":"audio/x-aiff",
  "arj":"application/x-arj-compressed",
  "asf":"video/x-ms-asf",
  "asx":"video/x-ms-asx",
  "au":"audio/ulaw",
  "avi":"video/x-msvideo",
  "bcpio":"application/x-bcpio",
  "ccad":"application/clariscad",
  "cod":"application/vnd.rim.cod",
  "com":"application/x-msdos-program",
  "cpio":"application/x-cpio",
  "cpt":"application/mac-compactpro",
  "csh":"application/x-csh",
  "css":"text/css",
  "deb":"application/x-debian-package",
  "dl":"video/dl",
  "doc":"application/msword",
  "drw":"application/drafting",
  "dvi":"application/x-dvi",
  "dwg":"application/acad",
  "dxf":"application/dxf",
  "dxr":"application/x-director",
  "etx":"text/x-setext",
  "ez":"application/andrew-inset",
  "fli":"video/x-fli",
  "flv":"video/x-flv",
  "gif":"image/gif",
  "gl":"video/gl",
  "gtar":"application/x-gtar",
  "gz":"application/x-gzip",
  "hdf":"application/x-hdf",
  "hqx":"application/mac-binhex40",
  "html":"text/html",
  "ice":"x-conference/x-cooltalk",
  "ico":"image/x-icon",
  "ief":"image/ief",
  "igs":"model/iges",
  "ips":"application/x-ipscript",
  "ipx":"application/x-ipix",
  "jad":"text/vnd.sun.j2me.app-descriptor",
  "jar":"application/java-archive",
  "jpeg":"image/jpeg",
  "jpg":"image/jpeg",
  "js":"text/javascript",
  "json":"application/json",
  "latex":"application/x-latex",
  "lsp":"application/x-lisp",
  "lzh":"application/octet-stream",
  "m":"text/plain",
  "m3u":"audio/x-mpegurl",
  "man":"application/x-troff-man",
  "me":"application/x-troff-me",
  "midi":"audio/midi",
  "mif":"application/x-mif",
  "mime":"www/mime",
  "movie":"video/x-sgi-movie",
  "mustache":"text/plain",
  "mp4":"video/mp4",
  "mpg":"video/mpeg",
  "mpga":"audio/mpeg",
  "ms":"application/x-troff-ms",
  "nc":"application/x-netcdf",
  "oda":"application/oda",
  "ogm":"application/ogg",
  "pbm":"image/x-portable-bitmap",
  "pdf":"application/pdf",
  "pgm":"image/x-portable-graymap",
  "pgn":"application/x-chess-pgn",
  "pgp":"application/pgp",
  "pm":"application/x-perl",
  "png":"image/png",
  "pnm":"image/x-portable-anymap",
  "ppm":"image/x-portable-pixmap",
  "ppz":"application/vnd.ms-powerpoint",
  "pre":"application/x-freelance",
  "prt":"application/pro_eng",
  "ps":"application/postscript",
  "qt":"video/quicktime",
  "ra":"audio/x-realaudio",
  "rar":"application/x-rar-compressed",
  "ras":"image/x-cmu-raster",
  "rgb":"image/x-rgb",
  "rm":"audio/x-pn-realaudio",
  "rpm":"audio/x-pn-realaudio-plugin",
  "rtf":"text/rtf",
  "rtx":"text/richtext",
  "scm":"application/x-lotusscreencam",
  "set":"application/set",
  "sgml":"text/sgml",
  "sh":"application/x-sh",
  "shar":"application/x-shar",
  "silo":"model/mesh",
  "sit":"application/x-stuffit",
  "skt":"application/x-koan",
  "smil":"application/smil",
  "snd":"audio/basic",
  "sol":"application/solids",
  "spl":"application/x-futuresplash",
  "src":"application/x-wais-source",
  "stl":"application/SLA",
  "stp":"application/STEP",
  "sv4cpio":"application/x-sv4cpio",
  "sv4crc":"application/x-sv4crc",
  "svg":"image/svg+xml",
  "swf":"application/x-shockwave-flash",
  "tar":"application/x-tar",
  "tcl":"application/x-tcl",
  "tex":"application/x-tex",
  "texinfo":"application/x-texinfo",
  "tgz":"application/x-tar-gz",
  "tiff":"image/tiff",
  "tr":"application/x-troff",
  "tsi":"audio/TSP-audio",
  "tsp":"application/dsptype",
  "tsv":"text/tab-separated-values",
  "unv":"application/i-deas",
  "ustar":"application/x-ustar",
  "vcd":"application/x-cdlink",
  "vda":"application/vda",
  "vivo":"video/vnd.vivo",
  "vrm":"x-world/x-vrml",
  "wav":"audio/x-wav",
  "wax":"audio/x-ms-wax",
  "wma":"audio/x-ms-wma",
  "wmv":"video/x-ms-wmv",
  "wmx":"video/x-ms-wmx",
  "wrl":"model/vrml",
  "wvx":"video/x-ms-wvx",
  "xbm":"image/x-xbitmap",
  "xlw":"application/vnd.ms-excel",
  "xml":"text/xml",
  "xpm":"image/x-xpixmap",
  "xwd":"image/x-xwindowdump",
  "xyz":"chemical/x-pdb",
  "zip":"application/zip",
};

exports.lookup = function(ext, defaultType) {
  defaultType = defaultType || 'application/octet-stream';

  return (ext in exports.types)
    ? exports.types[ext]
    : defaultType;
};
});

require.define("https", function (require, module, exports, __dirname, __filename) {
// todo

});

require.define("tls", function (require, module, exports, __dirname, __filename) {
// todo

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/level2/style.js", function (require, module, exports, __dirname, __filename) {
var core = require("./core").dom.level2.core,
    html = require("./html").dom.level2.html,
    utils = require("../utils"),
    cssom = require("cssom"),
    assert = require('assert');

// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325
core = Object.create(core);

// What works now:
// - Accessing the rules defined in individual stylesheets
// - Modifications to style content attribute are reflected in style property
// - Modifications to style property are reflected in style content attribute
// TODO
// - Modifications to style element's textContent are reflected in sheet property.
// - Modifications to style element's sheet property are reflected in textContent.
// - Modifications to link.href property are reflected in sheet property.
// - Less-used features of link: disabled
// - Less-used features of style: disabled, scoped, title
// - CSSOM-View
//   - getComputedStyle(): requires default stylesheet, cascading, inheritance,
//     filtering by @media (screen? print?), layout for widths/heights
// - Load events are not in the specs, but apparently some browsers
//   implement something. Should onload only fire after all @imports have been
//   loaded, or only the primary sheet?

core.StyleSheet = cssom.StyleSheet;
core.MediaList = cssom.MediaList;
core.CSSStyleSheet = cssom.CSSStyleSheet;
core.CSSRule = cssom.CSSRule;
core.CSSStyleRule = cssom.CSSStyleRule;
core.CSSMediaRule = cssom.CSSMediaRule;
core.CSSImportRule = cssom.CSSImportRule;
core.CSSStyleDeclaration = cssom.CSSStyleDeclaration;

// Relavant specs
// http://www.w3.org/TR/DOM-Level-2-Style (2000)
// http://www.w3.org/TR/cssom-view/ (2008)
// http://dev.w3.org/csswg/cssom/ (2010) Meant to replace DOM Level 2 Style
// http://www.whatwg.org/specs/web-apps/current-work/multipage/ HTML5, of course
// http://dev.w3.org/csswg/css-style-attr/  not sure what's new here

// Objects that aren't in cssom library but should be:
//   CSSRuleList  (cssom just uses array)
//   CSSFontFaceRule
//   CSSPageRule

// These rules don't really make sense to implement, so CSSOM draft makes them
// obsolete.
//   CSSCharsetRule
//   CSSUnknownRule

// These objects are considered obsolete by CSSOM draft, although modern
// browsers implement them.
//   CSSValue
//   CSSPrimitiveValue
//   CSSValueList
//   RGBColor
//   Rect
//   Counter

// StyleSheetList has the same interface as NodeList, so we'll use the same
// object.
core.StyleSheetList = core.NodeList;

core.Document.prototype.__defineGetter__('styleSheets', function() {
  if (!this._styleSheets) {
    this._styleSheets = new core.StyleSheetList();
  }
  // TODO: each style and link element should register its sheet on creation
  // nad remove it on removal.
  return this._styleSheets;
});


/**
 * @this {html.HTMLLinkElement|html.HTMLStyleElement}
 * @param {string} url
 * @param {cssom.CSSStyleSheet} sheet
 * @see http://dev.w3.org/csswg/cssom/#requirements-on-user-agents-implementing0
 */
function fetchStylesheet(url, sheet) {
  html.resourceLoader.load(this, url, function(data, filename) {
    // TODO: abort if the content-type is not text/css, and the document is
    // in strict mode
    evaluateStylesheet.call(this, data, sheet, url);
  });
}
/**
 * @this {html.HTMLLinkElement|html.HTMLStyleElement}
 * @param {string} data
 * @param {cssom.CSSStyleSheet} sheet
 * @param {string} baseUrl
 */
function evaluateStylesheet(data, sheet, baseUrl) {
  // this is the element
  var newStyleSheet = cssom.parse(data);
  var spliceArgs = newStyleSheet.cssRules;
  spliceArgs.unshift(0, sheet.cssRules.length);
  Array.prototype.splice.apply(sheet.cssRules, spliceArgs);
  scanForImportRules.call(this, sheet.cssRules, baseUrl);
}
/**
 * @this {html.HTMLLinkElement|html.HTMLStyleElement}
 * @param {cssom.CSSStyleSheet} sheet
 * @param {string} baseUrl
 */
function scanForImportRules(cssRules, baseUrl) {
  if (!cssRules) return;
  for (var i = 0; i < cssRules.length; ++i) {
    if (cssRules[i].cssRules) {
      // @media rule: keep searching inside it.
      scanForImportRules.call(this, cssRules[i].cssRules, baseUrl);
    } else if (cssRules[i].href) {
      // @import rule: fetch the resource and evaluate it.
      // See http://dev.w3.org/csswg/cssom/#css-import-rule
      //     If loading of the style sheet fails its cssRules list is simply
      //     empty. I.e. an @import rule always has an associated style sheet.
      fetchStylesheet.call(this, cssRules[i].href, self.sheet);
    }
  }
}

/**
 * @param {string} data
 * @param {cssom.CSSStyleDeclaration} style
 */
function evaluateStyleAttribute(data) {
  // this is the element.

  // currently, cssom's parse doesn't really work if you pass in
  // {state: 'name'}, so instead we just build a dummy sheet.
  var styleSheet = cssom.parse('dummy{' + data + '}');
  var style = this.style;
  while (style.length) {
    style.removeProperty(style[0]);
  }
  if (styleSheet.cssRules.length > 0 && styleSheet.cssRules[0].style) {
    var newStyle = styleSheet.cssRules[0].style;
    for (var i = 0; i < newStyle.length; ++i) {
      var prop = newStyle[i];
      style.setProperty(
          prop,
          newStyle.getPropertyValue(prop),
          newStyle.getPropertyPriority(prop));
    }
  }
}

/**
 * Subclass of core.Attr that reflects the current cssText.
 */
function StyleAttr(node, value) {
  this._node = node;
  core.Attr.call(this, node.ownerDocument, 'style');
  this.nodeValue = value;
}
StyleAttr.prototype = {
  get nodeValue() {
    return this._node.style.cssText;
  },
  set nodeValue(value) {
    evaluateStyleAttribute.call(this._node, value);
  }
};
StyleAttr.prototype.__proto__ = core.Attr.prototype;

/**
 * Overwrite core.AttrNodeMap#setNamedItem to create a StyleAttr instance
 * instead of a core.Attr if the name equals 'style'.
 */
utils.intercept(core.AttrNodeMap, 'setNamedItem', function(_super, args, attr) {
  if (attr.name == 'style') {
    attr = new StyleAttr(this._parentNode, attr.nodeValue);
  }
  return _super.call(this, attr);
});

/**
 * Lazily create a CSSStyleDeclaration.
 */
html.HTMLElement.prototype.__defineGetter__('style', function() {
  var style = this._cssStyleDeclaration;
  if (!style) {
    style = this._cssStyleDeclaration = new cssom.CSSStyleDeclaration();
    if (!this.getAttributeNode('style')) {
      this.setAttribute('style', '');
    }
  }
  return style;
});

assert.equal(undefined, html.HTMLLinkElement._init);
html.HTMLLinkElement._init = function() {
  this.addEventListener('DOMNodeInsertedIntoDocument', function() {
    if (!/(?:[ \t\n\r\f]|^)stylesheet(?:[ \t\n\r\f]|$)/i.test(this.rel)) {
      // rel is a space-separated list of tokens, and the original rel types
      // are case-insensitive.
      return;
    }
    if (this.href) {
      fetchStylesheet.call(this, this.href, this.sheet);
    }
  });
  this.addEventListener('DOMNodeRemovedFromDocument', function() {
  });
};
/**
 * @this {HTMLStyleElement|HTMLLinkElement}
 */
var getOrCreateSheet = function() {
  if (!this._cssStyleSheet) {
    this._cssStyleSheet = new cssom.CSSStyleSheet();
  }
  return this._cssStyleSheet;
};
html.HTMLLinkElement.prototype.__defineGetter__('sheet', getOrCreateSheet);

assert.equal(undefined, html.HTMLStyleElement._init);
html.HTMLStyleElement._init = function() {
  //console.log('init style')
  this.addEventListener('DOMNodeInsertedIntoDocument', function() {
    //console.log('style inserted')
    //console.log('sheet: ', this.sheet);
    if (this.type && this.type !== 'text/css') {
      //console.log('bad type: ' + this.type)
      return;
    }
    evaluateStylesheet.call(this, this.textContent, this.sheet, this._ownerDocument.URL);
  });
};
html.HTMLStyleElement.prototype.__defineGetter__('sheet', getOrCreateSheet);

exports.dom = {
  level2 : {
    html : html,
    core : core
  }
};

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/utils.js", function (require, module, exports, __dirname, __filename) {
/**
 * Intercepts a method by replacing the prototype's implementation
 * with a wrapper that invokes the given interceptor instead.
 * 
 *     utils.intercept(core.Element, 'inserBefore',
 *       function(_super, args, newChild, refChild) {
 *         console.log('insertBefore', newChild, refChild);
 *         return _super.apply(this, args);
 *       }
 *     );
 */
exports.intercept = function(clazz, method, interceptor) {
  var proto = clazz.prototype,
      _super = proto[method],
      unwrapArgs = interceptor.length > 2;

  proto[method] = function() {
    if (unwrapArgs) {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(_super, arguments);
      return interceptor.apply(this, args);
    }
    else {
      return interceptor.call(this, _super, arguments);
    }
  };
};

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/package.json", function (require, module, exports, __dirname, __filename) {
module.exports = {"main":"./lib/index.js"}
});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/index.js", function (require, module, exports, __dirname, __filename) {
'use strict';

exports.CSSStyleDeclaration = require('./CSSStyleDeclaration').CSSStyleDeclaration;
exports.CSSRule = require('./CSSRule').CSSRule;
exports.CSSStyleRule = require('./CSSStyleRule').CSSStyleRule;
exports.MediaList = require('./MediaList').MediaList;
exports.CSSMediaRule = require('./CSSMediaRule').CSSMediaRule;
exports.CSSImportRule = require('./CSSImportRule').CSSImportRule;
exports.StyleSheet = require('./StyleSheet').StyleSheet;
exports.CSSStyleSheet = require('./CSSStyleSheet').CSSStyleSheet;
exports.CSSKeyframesRule = require('./CSSKeyframesRule').CSSKeyframesRule;
exports.CSSKeyframeRule = require('./CSSKeyframeRule').CSSKeyframeRule;
exports.parse = require('./parse').parse;
exports.clone = require('./clone').clone;

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSStyleDeclaration.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {};
///CommonJS


/**
 * @constructor
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration
 */
CSSOM.CSSStyleDeclaration = function CSSStyleDeclaration(){
	this.length = 0;
	this.parentRule = null;

	// NON-STANDARD
	this._importants = {};
};


CSSOM.CSSStyleDeclaration.prototype = {

	constructor: CSSOM.CSSStyleDeclaration,

	/**
	 *
	 * @param {string} name
	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-getPropertyValue
	 * @return {string} the value of the property if it has been explicitly set for this declaration block.
	 * Returns the empty string if the property has not been set.
	 */
	getPropertyValue: function(name) {
		return this[name] || "";
	},

	/**
	 *
	 * @param {string} name
	 * @param {string} value
	 * @param {string} [priority=null] "important" or null
	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-setProperty
	 */
	setProperty: function(name, value, priority) {
		if (this[name]) {
			// Property already exist. Overwrite it.
			var index = Array.prototype.indexOf.call(this, name);
			if (index < 0) {
				this[this.length] = name;
				this.length++;
			}
		} else {
			// New property.
			this[this.length] = name;
			this.length++;
		}
		this[name] = value;
		this._importants[name] = priority;
	},

	/**
	 *
	 * @param {string} name
	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-removeProperty
	 * @return {string} the value of the property if it has been explicitly set for this declaration block.
	 * Returns the empty string if the property has not been set or the property name does not correspond to a known CSS property.
	 */
	removeProperty: function(name) {
		if (!(name in this)) {
			return "";
		}
		var index = Array.prototype.indexOf.call(this, name);
		if (index < 0) {
			return "";
		}
		var prevValue = this[name];
		this[name] = "";

		// That's what WebKit and Opera do
		Array.prototype.splice.call(this, index, 1);

		// That's what Firefox does
		//this[index] = ""

		return prevValue;
	},

	getPropertyCSSValue: function() {
		//FIXME
	},

	/**
	 *
	 * @param {String} name
	 */
	getPropertyPriority: function(name) {
		return this._importants[name] || "";
	},


	/**
	 *   element.style.overflow = "auto"
	 *   element.style.getPropertyShorthand("overflow-x")
	 *   -> "overflow"
	 */
	getPropertyShorthand: function() {
		//FIXME
	},

	isPropertyImplicit: function() {
		//FIXME
	},

	// Doesn't work in IE < 9
	get cssText(){
		var properties = [];
		for (var i=0, length=this.length; i < length; ++i) {
			var name = this[i];
			var value = this.getPropertyValue(name);
			var priority = this.getPropertyPriority(name);
			if (priority) {
				priority = " !" + priority;
			}
			properties[i] = name + ": " + value + priority + ";";
		}
		return properties.join(" ");
	},

	set cssText(cssText){
		var i, name;
		for (i = this.length; i--;) {
			name = this[i];
			this[name] = "";
		}
		Array.prototype.splice.call(this, 0, this.length);
		this._importants = {};

		var dummyRule = CSSOM.parse('#bogus{' + cssText + '}').cssRules[0].style;
		var length = dummyRule.length;
		for (i = 0; i < length; ++i) {
			name = dummyRule[i];
			this.setProperty(dummyRule[i], dummyRule.getPropertyValue(name), dummyRule.getPropertyPriority(name));
		}
	}
};


//.CommonJS
exports.CSSStyleDeclaration = CSSOM.CSSStyleDeclaration;
CSSOM.parse = require('./parse').parse; // Cannot be included sooner due to the mutual dependency between parse.js and CSSStyleDeclaration.js
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/parse.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	CSSStyleSheet: require("./CSSStyleSheet").CSSStyleSheet,
	CSSStyleRule: require("./CSSStyleRule").CSSStyleRule,
	CSSImportRule: require("./CSSImportRule").CSSImportRule,
	CSSMediaRule: require("./CSSMediaRule").CSSMediaRule,
	CSSStyleDeclaration: require('./CSSStyleDeclaration').CSSStyleDeclaration,
	CSSKeyframeRule: require('./CSSKeyframeRule').CSSKeyframeRule,
	CSSKeyframesRule: require('./CSSKeyframesRule').CSSKeyframesRule
};
///CommonJS


/**
 * @param {string} token
 */
CSSOM.parse = function parse(token) {

	var i = 0;

	/**
	  "before-selector" or
	  "selector" or
	  "atRule" or
	  "atBlock" or
	  "before-name" or
	  "name" or
	  "before-value" or
	  "value"
	*/
	var state = "before-selector";

	var index;
	var buffer = "";

	var SIGNIFICANT_WHITESPACE = {
		"selector": true,
		"value": true,
		"atRule": true,
		"importRule-begin": true,
		"importRule": true,
		"atBlock": true
	};

	var styleSheet = new CSSOM.CSSStyleSheet;

	// @type CSSStyleSheet|CSSMediaRule|CSSKeyframesRule
	var currentScope = styleSheet;

	// @type CSSMediaRule|CSSKeyframesRule
	var parentRule;

	var selector, name, value, priority="", styleRule, mediaRule, importRule, keyframesRule, keyframeRule;

	var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;

	for (var character; character = token.charAt(i); i++) {

		switch (character) {

		case " ":
		case "\t":
		case "\r":
		case "\n":
		case "\f":
			if (SIGNIFICANT_WHITESPACE[state]) {
				buffer += character;
			}
			break;

		// String
		case '"':
			index = token.indexOf('"', i + 1) + 1;
			if (!index) {
				throw '" is missing';
			}
			buffer += token.slice(i, index);
			i = index - 1;
			switch (state) {
				case 'before-value':
					state = 'value';
					break;
				case 'importRule-begin':
					state = 'importRule';
					break;
			}
			break;

		case "'":
			index = token.indexOf("'", i + 1) + 1;
			if (!index) {
				throw "' is missing";
			}
			buffer += token.slice(i, index);
			i = index - 1;
			switch (state) {
				case 'before-value':
					state = 'value';
					break;
				case 'importRule-begin':
					state = 'importRule';
					break;
			}
			break;

		// Comment
		case "/":
			if (token.charAt(i + 1) === "*") {
				i += 2;
				index = token.indexOf("*/", i);
				if (index === -1) {
					throw new SyntaxError("Missing */");
				} else {
					i = index + 1;
				}
			} else {
				buffer += character;
			}
			if (state === "importRule-begin") {
				buffer += " ";
				state = "importRule";
			}
			break;

		// At-rule
		case "@":
			if (token.indexOf("@media", i) === i) {
				state = "atBlock";
				mediaRule = new CSSOM.CSSMediaRule;
				mediaRule.__starts = i;
				i += "media".length;
				buffer = "";
				break;
			} else if (token.indexOf("@import", i) === i) {
				state = "importRule-begin";
				i += "import".length;
				buffer += "@import";
				break;
			} else {
				atKeyframesRegExp.lastIndex = i;
				var matchKeyframes = atKeyframesRegExp.exec(token);
				if (matchKeyframes && matchKeyframes.index === i) {
					state = "keyframesRule-begin";
					keyframesRule = new CSSOM.CSSKeyframesRule;
					keyframesRule.__starts = i;
					keyframesRule._vendorPrefix = matchKeyframes[1]; // Will come out as undefined if no prefix was found
					i += matchKeyframes[0].length - 1;
					buffer = "";
					break;
				} else if (state == "selector") {
					state = "atRule";
				}
			}
			buffer += character;
			break;

		case "{":
			if (state === "selector" || state === "atRule") {
				styleRule.selectorText = buffer.trim();
				styleRule.style.__starts = i;
				buffer = "";
				state = "before-name";
			} else if (state === "atBlock") {
				mediaRule.media.mediaText = buffer.trim();
				currentScope = parentRule = mediaRule;
				mediaRule.parentStyleSheet = styleSheet;
				buffer = "";
				state = "before-selector";
			} else if (state === "keyframesRule-begin") {
				keyframesRule.name = buffer.trim();
				if (parentRule) {
					keyframesRule.parentRule = parentRule;
				}
				keyframesRule.parentStyleSheet = styleSheet;
				currentScope = parentRule = keyframesRule;
				buffer = "";
				state = "keyframeRule-begin";
			} else if (state === "keyframeRule-begin") {
				styleRule = new CSSOM.CSSKeyframeRule;
				styleRule.keyText = buffer.trim();
				styleRule.__starts = i;
				buffer = "";
				state = "before-name";
			}
			break;

		case ":":
			if (state === "name") {
				name = buffer.trim();
				buffer = "";
				state = "before-value";
			} else {
				buffer += character;
			}
			break;

		case '(':
			if (state === 'value') {
				index = token.indexOf(')', i + 1);
				if (index === -1) {
					throw i + ': unclosed "("';
				}
				buffer += token.slice(i, index + 1);
				i = index;
			} else {
				buffer += character;
			}
			break;

		case "!":
			if (state === "value" && token.indexOf("!important", i) === i) {
				priority = "important";
				i += "important".length;
			} else {
				buffer += character;
			}
			break;

		case ";":
			switch (state) {
				case "value":
					styleRule.style.setProperty(name, buffer.trim(), priority);
					priority = "";
					buffer = "";
					state = "before-name";
					break;
				case "atRule":
					buffer = "";
					state = "before-selector";
					break;
				case "importRule":
					importRule = new CSSOM.CSSImportRule;
					importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
					importRule.cssText = buffer + character;
					styleSheet.cssRules.push(importRule);
					buffer = "";
					state = "before-selector";
					break;
				default:
					buffer += character;
					break;
			}
			break;

		case "}":
			switch (state) {
				case "value":
					styleRule.style.setProperty(name, buffer.trim(), priority);
					priority = "";
				case "before-name":
				case "name":
					styleRule.__ends = i + 1;
					if (parentRule) {
						styleRule.parentRule = parentRule;
					}
					styleRule.parentStyleSheet = styleSheet;
					currentScope.cssRules.push(styleRule);
					buffer = "";
					if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
						state = "keyframeRule-begin";
					} else {
						state = "before-selector";
					}
					break;
				case "keyframeRule-begin":
				case "before-selector":
				case "selector":
					// End of media rule.
					if (!parentRule) {
						throw "unexpected }";
					}
					currentScope.__ends = i + 1;
					// Nesting rules arenâ€™t supported yet
					styleSheet.cssRules.push(currentScope);
					currentScope = styleSheet;
					parentRule = null;
					buffer = "";
					state = "before-selector";
					break;
			}
			break;

		default:
			switch (state) {
				case "before-selector":
					state = "selector";
					styleRule = new CSSOM.CSSStyleRule;
					styleRule.__starts = i;
					break;
				case "before-name":
					state = "name";
					break;
				case "before-value":
					state = "value";
					break;
				case "importRule-begin":
					state = "importRule";
					break;
			}
			buffer += character;
			break;
		}
	}

	return styleSheet;
};


//.CommonJS
exports.parse = CSSOM.parse;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSStyleSheet.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	StyleSheet: require("./StyleSheet").StyleSheet,
	CSSStyleRule: require("./CSSStyleRule").CSSStyleRule
};
///CommonJS


/**
 * @constructor
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet
 */
CSSOM.CSSStyleSheet = function CSSStyleSheet() {
	CSSOM.StyleSheet.call(this);
	this.cssRules = [];
};


CSSOM.CSSStyleSheet.prototype = new CSSOM.StyleSheet;
CSSOM.CSSStyleSheet.prototype.constructor = CSSOM.CSSStyleSheet;


/**
 * Used to insert a new rule into the style sheet. The new rule now becomes part of the cascade.
 *
 *   sheet = new Sheet("body {margin: 0}")
 *   sheet.toString()
 *   -> "body{margin:0;}"
 *   sheet.insertRule("img {border: none}", 0)
 *   -> 0
 *   sheet.toString()
 *   -> "img{border:none;}body{margin:0;}"
 *
 * @param {string} rule
 * @param {number} index
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-insertRule
 * @return {number} The index within the style sheet's rule collection of the newly inserted rule.
 */
CSSOM.CSSStyleSheet.prototype.insertRule = function(rule, index) {
	if (index < 0 || index > this.cssRules.length) {
		throw new RangeError("INDEX_SIZE_ERR");
	}
	this.cssRules.splice(index, 0, CSSOM.CSSStyleRule.parse(rule));
	return index;
};


/**
 * Used to delete a rule from the style sheet.
 *
 *   sheet = new Sheet("img{border:none} body{margin:0}")
 *   sheet.toString()
 *   -> "img{border:none;}body{margin:0;}"
 *   sheet.deleteRule(0)
 *   sheet.toString()
 *   -> "body{margin:0;}"
 *
 * @param {number} index within the style sheet's rule list of the rule to remove.
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-deleteRule
 */
CSSOM.CSSStyleSheet.prototype.deleteRule = function(index) {
	if (index < 0 || index >= this.cssRules.length) {
		throw new RangeError("INDEX_SIZE_ERR");
	}
	this.cssRules.splice(index, 1);
};


/**
 * NON-STANDARD
 * @return {string} serialize stylesheet
 */
CSSOM.CSSStyleSheet.prototype.toString = function() {
	var result = "";
	var rules = this.cssRules;
	for (var i=0; i<rules.length; i++) {
		result += rules[i].cssText + "\n";
	}
	return result;
};


//.CommonJS
exports.CSSStyleSheet = CSSOM.CSSStyleSheet;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/StyleSheet.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {};
///CommonJS


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#the-stylesheet-interface
 */
CSSOM.StyleSheet = function StyleSheet() {
	this.parentStyleSheet = null;
};


//.CommonJS
exports.StyleSheet = CSSOM.StyleSheet;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSStyleRule.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	CSSStyleDeclaration: require("./CSSStyleDeclaration").CSSStyleDeclaration,
	CSSRule: require("./CSSRule").CSSRule
};
///CommonJS


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#cssstylerule
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleRule
 */
CSSOM.CSSStyleRule = function CSSStyleRule() {
	CSSOM.CSSRule.call(this);
	this.selectorText = "";
	this.style = new CSSOM.CSSStyleDeclaration;
	this.style.parentRule = this;
};

CSSOM.CSSStyleRule.prototype = new CSSOM.CSSRule;
CSSOM.CSSStyleRule.prototype.constructor = CSSOM.CSSStyleRule;
CSSOM.CSSStyleRule.prototype.type = 1;

CSSOM.CSSStyleRule.prototype.__defineGetter__("cssText", function() {
	var text;
	if (this.selectorText) {
		text = this.selectorText + " {" + this.style.cssText + "}";
	} else {
		text = "";
	}
	return text;
});

CSSOM.CSSStyleRule.prototype.__defineSetter__("cssText", function(cssText) {
	var rule = CSSOM.CSSStyleRule.parse(cssText);
	this.style = rule.style;
	this.selectorText = rule.selectorText;
});


/**
 * NON-STANDARD
 * lightweight version of parse.js.
 * @param {string} ruleText
 * @return CSSStyleRule
 */
CSSOM.CSSStyleRule.parse = function(ruleText) {
	var i = 0;
	var state = "selector";
	var index;
	var j = i;
	var buffer = "";

	var SIGNIFICANT_WHITESPACE = {
		"selector": true,
		"value": true
	};

	var styleRule = new CSSOM.CSSStyleRule;
	var selector, name, value, priority="";

	for (var character; character = ruleText.charAt(i); i++) {

		switch (character) {

		case " ":
		case "\t":
		case "\r":
		case "\n":
		case "\f":
			if (SIGNIFICANT_WHITESPACE[state]) {
				// Squash 2 or more white-spaces in the row into 1
				switch (ruleText.charAt(i - 1)) {
					case " ":
					case "\t":
					case "\r":
					case "\n":
					case "\f":
						break;
					default:
						buffer += " ";
						break;
				}
			}
			break;

		// String
		case '"':
			j = i + 1;
			index = ruleText.indexOf('"', j) + 1;
			if (!index) {
				throw '" is missing';
			}
			buffer += ruleText.slice(i, index);
			i = index - 1;
			break;

		case "'":
			j = i + 1;
			index = ruleText.indexOf("'", j) + 1;
			if (!index) {
				throw "' is missing";
			}
			buffer += ruleText.slice(i, index);
			i = index - 1;
			break;

		// Comment
		case "/":
			if (ruleText.charAt(i + 1) === "*") {
				i += 2;
				index = ruleText.indexOf("*/", i);
				if (index === -1) {
					throw new SyntaxError("Missing */");
				} else {
					i = index + 1;
				}
			} else {
				buffer += character;
			}
			break;

		case "{":
			if (state === "selector") {
				styleRule.selectorText = buffer.trim();
				buffer = "";
				state = "name";
			}
			break;

		case ":":
			if (state === "name") {
				name = buffer.trim();
				buffer = "";
				state = "value";
			} else {
				buffer += character;
			}
			break;

		case "!":
			if (state === "value" && ruleText.indexOf("!important", i) === i) {
				priority = "important";
				i += "important".length;
			} else {
				buffer += character;
			}
			break;

		case ";":
			if (state === "value") {
				styleRule.style.setProperty(name, buffer.trim(), priority);
				priority = "";
				buffer = "";
				state = "name";
			} else {
				buffer += character;
			}
			break;

		case "}":
			if (state === "value") {
				styleRule.style.setProperty(name, buffer.trim(), priority);
				priority = "";
				buffer = "";
			} else if (state === "name") {
				break;
			} else {
				buffer += character;
			}
			state = "selector";
			break;

		default:
			buffer += character;
			break;

		}
	}

	return styleRule;

};


//.CommonJS
exports.CSSStyleRule = CSSOM.CSSStyleRule;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSRule.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {};
///CommonJS


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#the-cssrule-interface
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSRule
 */
CSSOM.CSSRule = function CSSRule() {
	this.parentRule = null;
	this.parentStyleSheet = null;
};

CSSOM.CSSRule.STYLE_RULE = 1;
CSSOM.CSSRule.IMPORT_RULE = 3;
CSSOM.CSSRule.MEDIA_RULE = 4;
CSSOM.CSSRule.FONT_FACE_RULE = 5;
CSSOM.CSSRule.PAGE_RULE = 6;
CSSOM.CSSRule.WEBKIT_KEYFRAMES_RULE = 8;
CSSOM.CSSRule.WEBKIT_KEYFRAME_RULE = 9;

// Obsolete in CSSOM http://dev.w3.org/csswg/cssom/
//CSSOM.CSSRule.UNKNOWN_RULE = 0;
//CSSOM.CSSRule.CHARSET_RULE = 2;

// Never implemented
//CSSOM.CSSRule.VARIABLES_RULE = 7;

CSSOM.CSSRule.prototype = {
	constructor: CSSOM.CSSRule
	//FIXME
};


//.CommonJS
exports.CSSRule = CSSOM.CSSRule;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSImportRule.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	CSSRule: require("./CSSRule").CSSRule,
	CSSStyleSheet: require("./CSSStyleSheet").CSSStyleSheet,
	MediaList: require("./MediaList").MediaList
};
///CommonJS


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#cssimportrule
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSImportRule
 */
CSSOM.CSSImportRule = function CSSImportRule() {
	CSSOM.CSSRule.call(this);
	this.href = "";
	this.media = new CSSOM.MediaList;
	this.styleSheet = new CSSOM.CSSStyleSheet;
};

CSSOM.CSSImportRule.prototype = new CSSOM.CSSRule;
CSSOM.CSSImportRule.prototype.constructor = CSSOM.CSSImportRule;
CSSOM.CSSImportRule.prototype.type = 3;
CSSOM.CSSImportRule.prototype.__defineGetter__("cssText", function() {
	var mediaText = this.media.mediaText;
	return "@import url(" + this.href + ")" + (mediaText ? " " + mediaText : "") + ";";
});

CSSOM.CSSImportRule.prototype.__defineSetter__("cssText", function(cssText) {
	var i = 0;

	/**
	 * @import url(partial.css) screen, handheld;
	 *        ||               |
	 *        after-import     media
	 *         |
	 *         url
	 */
	var state = '';

	var buffer = '';
	var index;
	var mediaText = '';
	for (var character; character = cssText.charAt(i); i++) {

		switch (character) {
			case ' ':
			case '\t':
			case '\r':
			case '\n':
			case '\f':
				if (state === 'after-import') {
					state = 'url';
				} else {
					buffer += character;
				}
				break;

			case '@':
				if (!state && cssText.indexOf('@import', i) === i) {
					state = 'after-import';
					i += 'import'.length;
					buffer = '';
				}
				break;

			case 'u':
				if (state === 'url' && cssText.indexOf('url(', i) === i) {
					index = cssText.indexOf(')', i + 1);
					if (index === -1) {
						throw i + ': ")" not found';
					}
					i += 'url('.length;
					var url = cssText.slice(i, index);
					if (url[0] === url[url.length - 1]) {
						if (url[0] === '"' || url[0] === "'") {
							url = url.slice(1, -1);
						}
					}
					this.href = url;
					i = index;
					state = 'media';
				}
				break;

			case '"':
				if (state === 'url') {
					index = cssText.indexOf('"', i + 1);
					if (!index) {
						throw i + ": '\"' not found";
					}
					this.href = cssText.slice(i + 1, index);
					i = index;
					state = 'media';
				}
				break;

			case "'":
				if (state === 'url') {
					index = cssText.indexOf("'", i + 1);
					if (!index) {
						throw i + ': "\'" not found';
					}
					this.href = cssText.slice(i + 1, index);
					i = index;
					state = 'media';
				}
				break;

			case ';':
				if (state === 'media') {
					if (buffer) {
						this.media.mediaText = buffer.trim();
					}
				}
				break;

			default:
				if (state === 'media') {
					buffer += character;
				}
				break;
		}
	}
});


//.CommonJS
exports.CSSImportRule = CSSOM.CSSImportRule;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/MediaList.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {};
///CommonJS


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#the-medialist-interface
 */
CSSOM.MediaList = function MediaList(){
	this.length = 0;
};

CSSOM.MediaList.prototype = {

	constructor: CSSOM.MediaList,

	/**
	 * @return {string}
	 */
	get mediaText() {
		return Array.prototype.join.call(this, ", ");
	},

	/**
	 * @param {string} value
	 */
	set mediaText(value) {
		var values = value.split(",");
		var length = this.length = values.length;
		for (var i=0; i<length; i++) {
			this[i] = values[i].trim();
		}
	},

	/**
	 * @param {string} medium
	 */
	appendMedium: function(medium) {
		if (Array.prototype.indexOf.call(this, medium) === -1) {
			this[this.length] = medium;
			this.length++;
		}
	},

	/**
	 * @param {string} medium
	 */
	deleteMedium: function(medium) {
		var index = Array.prototype.indexOf.call(this, medium);
		if (index !== -1) {
			Array.prototype.splice.call(this, index, 1);
		}
	}

};


//.CommonJS
exports.MediaList = CSSOM.MediaList;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSMediaRule.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	CSSRule: require("./CSSRule").CSSRule,
	MediaList: require("./MediaList").MediaList
};
///CommonJS


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#cssmediarule
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSMediaRule
 */
CSSOM.CSSMediaRule = function CSSMediaRule() {
	CSSOM.CSSRule.call(this);
	this.media = new CSSOM.MediaList;
	this.cssRules = [];
};

CSSOM.CSSMediaRule.prototype = new CSSOM.CSSRule;
CSSOM.CSSMediaRule.prototype.constructor = CSSOM.CSSMediaRule;
CSSOM.CSSMediaRule.prototype.type = 4;
//FIXME
//CSSOM.CSSMediaRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSMediaRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

// http://opensource.apple.com/source/WebCore/WebCore-658.28/css/CSSMediaRule.cpp
CSSOM.CSSMediaRule.prototype.__defineGetter__("cssText", function() {
	var cssTexts = [];
	for (var i=0, length=this.cssRules.length; i < length; i++) {
		cssTexts.push(this.cssRules[i].cssText);
	}
	return "@media " + this.media.mediaText + " {" + cssTexts.join("") + "}";
});


//.CommonJS
exports.CSSMediaRule = CSSOM.CSSMediaRule;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSKeyframeRule.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	CSSRule: require("./CSSRule").CSSRule,
	CSSStyleDeclaration: require('./CSSStyleDeclaration').CSSStyleDeclaration
};
///CommonJS


/**
 * @constructor
 * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframeRule
 */
CSSOM.CSSKeyframeRule = function CSSKeyframeRule() {
	CSSOM.CSSRule.call(this);
	this.keyText = '';
	this.style = new CSSOM.CSSStyleDeclaration;
	this.style.parentRule = this;
};

CSSOM.CSSKeyframeRule.prototype = new CSSOM.CSSRule;
CSSOM.CSSKeyframeRule.prototype.constructor = CSSOM.CSSKeyframeRule;
CSSOM.CSSKeyframeRule.prototype.type = 9;
//FIXME
//CSSOM.CSSKeyframeRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSKeyframeRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframeRule.cpp
CSSOM.CSSKeyframeRule.prototype.__defineGetter__("cssText", function() {
	return this.keyText + " { " + this.style.cssText + " } ";
});


//.CommonJS
exports.CSSKeyframeRule = CSSOM.CSSKeyframeRule;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/CSSKeyframesRule.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	CSSRule: require("./CSSRule").CSSRule
};
///CommonJS


/**
 * @constructor
 * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframesRule
 */
CSSOM.CSSKeyframesRule = function CSSKeyframesRule() {
	CSSOM.CSSRule.call(this);
	this.name = '';
	this.cssRules = [];
};

CSSOM.CSSKeyframesRule.prototype = new CSSOM.CSSRule;
CSSOM.CSSKeyframesRule.prototype.constructor = CSSOM.CSSKeyframesRule;
CSSOM.CSSKeyframesRule.prototype.type = 8;
//FIXME
//CSSOM.CSSKeyframesRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSKeyframesRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframesRule.cpp
CSSOM.CSSKeyframesRule.prototype.__defineGetter__("cssText", function() {
	var cssTexts = [];
	for (var i=0, length=this.cssRules.length; i < length; i++) {
		cssTexts.push("  " + this.cssRules[i].cssText);
	}
	return "@" + (this._vendorPrefix || '') + "keyframes " + this.name + " { \n" + cssTexts.join("\n") + "\n}";
});


//.CommonJS
exports.CSSKeyframesRule = CSSOM.CSSKeyframesRule;
///CommonJS

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/cssom/lib/clone.js", function (require, module, exports, __dirname, __filename) {
//.CommonJS
var CSSOM = {
	CSSStyleSheet: require("./CSSStyleSheet").CSSStyleSheet,
	CSSStyleRule: require("./CSSStyleRule").CSSStyleRule,
	CSSMediaRule: require("./CSSMediaRule").CSSMediaRule,
	CSSStyleDeclaration: require("./CSSStyleDeclaration").CSSStyleDeclaration,
	CSSKeyframeRule: require('./CSSKeyframeRule').CSSKeyframeRule,
	CSSKeyframesRule: require('./CSSKeyframesRule').CSSKeyframesRule
};
///CommonJS


/**
 * Produces a deep copy of stylesheet — the instance variables of stylesheet are copied recursively.
 * @param {CSSStyleSheet|CSSOM.CSSStyleSheet} stylesheet
 * @nosideeffects
 * @return {CSSOM.CSSStyleSheet}
 */
CSSOM.clone = function clone(stylesheet) {

	var cloned = new CSSOM.CSSStyleSheet;

	var rules = stylesheet.cssRules;
	if (!rules) {
		return cloned;
	}

	var RULE_TYPES = {
		1: CSSOM.CSSStyleRule,
		4: CSSOM.CSSMediaRule,
		//3: CSSOM.CSSImportRule,
		//5: CSSOM.CSSFontFaceRule,
		//6: CSSOM.CSSPageRule,
		8: CSSOM.CSSKeyframesRule,
		9: CSSOM.CSSKeyframeRule
	};

	for (var i=0, rulesLength=rules.length; i < rulesLength; i++) {
		var rule = rules[i];
		var ruleClone = cloned.cssRules[i] = new RULE_TYPES[rule.type];

		var style = rule.style;
		if (style) {
			var styleClone = ruleClone.style = new CSSOM.CSSStyleDeclaration;
			for (var j=0, styleLength=style.length; j < styleLength; j++) {
				var name = styleClone[j] = style[j];
				styleClone[name] = style[name];
				styleClone._importants[name] = style.getPropertyPriority(name);
			}
			styleClone.length = style.length;
		}

		if (rule.hasOwnProperty('keyText')) {
			ruleClone.keyText = rule.keyText;
		}

		if (rule.hasOwnProperty('selectorText')) {
			ruleClone.selectorText = rule.selectorText;
		}

		if (rule.hasOwnProperty('mediaText')) {
			ruleClone.mediaText = rule.mediaText;
		}

		if (rule.hasOwnProperty('cssRules')) {
			ruleClone.cssRules = clone(rule).cssRules;
		}
	}

	return cloned;

};

//.CommonJS
exports.clone = CSSOM.clone;
///CommonJS

});

require.define("assert", function (require, module, exports, __dirname, __filename) {
// UTILITY
var util = require('util');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/browser/index.js", function (require, module, exports, __dirname, __filename) {
var sys           = require('sys'),
    http          = require('http'),
    URL           = require('url'),
    HtmlToDom     = require('./htmltodom').HtmlToDom,
    domToHtml     = require('./domtohtml').domToHtml,
    htmlencoding  = require('./htmlencoding'),
    HTMLEncode    = htmlencoding.HTMLEncode,
    HTMLDecode    = htmlencoding.HTMLDecode,
    jsdom         = require('../../jsdom'),
    Contextify    = require('contextify');

function NOT_IMPLEMENTED(target) {
  return function() {
    if (!jsdom.debugMode) {
      var trigger = target ? target.trigger : this.trigger;
      trigger.call(this, 'error', 'NOT IMPLEMENTED');
    }
  };
}

/**
 * Creates a window having a document. The document can be passed as option,
 * if omitted, a new document will be created.
 */
exports.windowAugmentation = function(dom, options) {
  options = options || {};
  var window = exports.createWindow(dom, options);

  if (!options.document) {
    var browser = browserAugmentation(dom, options);

    if (options.features && options.features.QuerySelector) {
      require(__dirname + "/../selectors/index").applyQuerySelectorPrototype(browser);
    }

    options.document = (browser.HTMLDocument)             ?
                        new browser.HTMLDocument(options) :
                        new browser.Document(options);



    options.document.write('<html><head></head><body></body></html>');
  }

  var doc = window.document = options.document;

  if (doc.addEventListener) {
    if (doc.readyState == 'complete') {
      var ev = doc.createEvent('HTMLEvents');
      ev.initEvent('load', false, false);
      window.dispatchEvent(ev);
    }
    else {
      doc.addEventListener('load', function(ev) {
        window.dispatchEvent(ev);
      });
    }
  }

  return window;
};

/**
 * Creates a document-less window.
 */
exports.createWindow = function(dom, options) {
  var timers = [];

  function startTimer(startFn, stopFn, callback, ms) {
	  var res = startFn(callback, ms);
	  timers.push( [ res, stopFn ] );
	  return res;
  }

  function stopTimer(id) {
	  if (typeof id === 'undefined') {
		  return;
	  }
	  for (var i in timers) {
		  if (timers[i][0] === id) {
			  timers[i][1].call(this, id);
			  timers.splice(i, 1);
			  break;
		  }
	  }
  }

  function stopAllTimers() {
	  timers.forEach(function (t) {
		  t[1].call(this, t[0]);
	  });
	  timers = [];
  }

  function DOMWindow(options) {
    var href = (options || {}).url || 'file://' + __filename;
    this.location = URL.parse(href);
    this.location.reload = NOT_IMPLEMENTED(this);
    this.location.replace = NOT_IMPLEMENTED(this);
    this.location.toString = function() {
      return href;
    };

    var window = this.console._window = this;

    /* Location hash support */
    this.location.__defineGetter__("hash", function() {
      return (window.location.href.split("#").length > 1)
        ? "#"+window.location.href.split("#")[1]
        : "";
    });

    this.location.__defineSetter__("hash", function(val) {
      /* TODO: Should fire a hashchange event, but tests aren't working */
      window.location.href = window.location.href.split("#")[0] + val;
    });

    /* Location search support */
    this.location.__defineGetter__("search", function() {
      return (window.location.href.split("?").length > 1)
        ? "?"+window.location.href.match(/\?([^#]+)/)[1]
        : "";
    });

    this.location.__defineSetter__("search", function(val) {
      window.location.href = (window.location.href.indexOf("?") > 0)
        ? window.location.href.replace(/\?([^#]+)/, val)
        : window.location.href.match(/^([^#?]+)/)[0] + val + window.location.hash;
    });

    if (options && options.document) {
      options.document.location = this.location;
    }
    this.addEventListener = function() {
      dom.Node.prototype.addEventListener.apply(window, arguments);
    };
    this.removeEventListener = function() {
      dom.Node.prototype.removeEventListener.apply(window, arguments);
    };
    this.dispatchEvent = function() {
      dom.Node.prototype.dispatchEvent.apply(window, arguments);
    };
    this.trigger = function(){
      dom.Node.prototype.trigger.apply(window.document, arguments);
    };

    this.setTimeout = function (fn, ms) { return startTimer(setTimeout, clearTimeout, fn, ms); };
    this.setInterval = function (fn, ms) { return startTimer(setInterval, clearInterval, fn, ms); };
    this.clearInterval = stopTimer;
    this.clearTimeout = stopTimer;
    this.__stopAllTimers = stopAllTimers;
  }

  DOMWindow.prototype = {
    __proto__: dom,
    // This implements window.frames.length, since window.frames returns a
    // self reference to the window object.  This value is incremented in the
    // HTMLFrameElement init function (see: level2/html.js).
    _length : 0,
    get length () {
      return this._length;
    },
    close : function() {
      // Recursively close child frame windows, then ourselves.
      var currentWindow = this;
      (function windowCleaner (window) {
        var i;
        // We could call window.frames.length etc, but window.frames just points
        // back to window.
        if (window.length > 0) {
          for (i = 0; i < window.length; i++) {
            windowCleaner(window[i]);
          }
        }
        // We're already in our own window.close().
        if (window !== currentWindow) {
          window.close();
        }
      })(this);

      if (this.document) {
        if (this.document.body) {
          this.document.body.innerHTML = "";
        }

        if (this.document.close) {
          // We need to empty out the event listener array because
          // document.close() causes 'load' event to re-fire.
          this.document._listeners = [];
          this.document.close();
        }
        delete this.document;
      }

      stopAllTimers();
      // Clean up the window's execution context.
      // dispose() is added by Contextify.
      this.dispose();
    },
    getComputedStyle: function(node) {
      var s = node.style,
          cs = {};

      for (var n in s) {
        cs[n] = s[n];
      }
      cs.__proto__ = {
        getPropertyValue: function(name) {
          return node.style[name];
        }
      };
      return cs;
    },
    console: {
      log:   function(message) { this._window.trigger('log',   message) },
      info:  function(message) { this._window.trigger('info',  message) },
      warn:  function(message) { this._window.trigger('warn',  message) },
      error: function(message) { this._window.trigger('error', message) }
    },
    navigator: {
      userAgent: 'Node.js (' + process.platform + '; U; rv:' + process.version + ')',
      appName: 'Node.js jsDom',
      platform: process.platform,
      appVersion: process.version
    },
    XMLHttpRequest: function XMLHttpRequest() {},

    name: 'nodejs',
    innerWidth: 1024,
    innerHeight: 768,
    outerWidth: 1024,
    outerHeight: 768,
    pageXOffset: 0,
    pageYOffset: 0,
    screenX: 0,
    screenY: 0,
    screenLeft: 0,
    screenTop: 0,
    scrollX: 0,
    scrollY: 0,
    scrollTop: 0,
    scrollLeft: 0,
    alert: NOT_IMPLEMENTED(),
    blur: NOT_IMPLEMENTED(),
    confirm: NOT_IMPLEMENTED(),
    createPopup: NOT_IMPLEMENTED(),
    focus: NOT_IMPLEMENTED(),
    moveBy: NOT_IMPLEMENTED(),
    moveTo: NOT_IMPLEMENTED(),
    open: NOT_IMPLEMENTED(),
    print: NOT_IMPLEMENTED(),
    prompt: NOT_IMPLEMENTED(),
    resizeBy: NOT_IMPLEMENTED(),
    resizeTo: NOT_IMPLEMENTED(),
    scroll: NOT_IMPLEMENTED(),
    scrollBy: NOT_IMPLEMENTED(),
    scrollTo: NOT_IMPLEMENTED(),
    screen : {
      width : 0,
      height : 0
    },
    Image : NOT_IMPLEMENTED()
  };

  var window = new DOMWindow(options);

  Contextify(window);

  // We need to set up self references using Contextify's getGlobal() so that
  // the global object identity is correct (window === this).
  // See Contextify README for more info.
  var global = window.getGlobal();

  // Set up the window as if it's a top level window.
  // If it's not, then references will be corrected by frame/iframe code.
  // Note: window.frames is maintained in the HTMLFrameElement init function.
  window.window = window.frames
                = window.self
                = window.parent
                = window.top = global;

  return window;
};

//Caching for HTMLParser require. HUGE performace boost.
/**
* 5000 iterations
* Without cache: ~1800+ms
* With cache: ~80ms
*/
var defaultParser = null;
function getDefaultParser() {
  if (defaultParser === null) {
    try {
      defaultParser = require('htmlparser');
    }
    catch (e) {
      try {
        defaultParser = require('htmlparser/lib/node-htmlparser');
      }
      catch (e2) {
        defaultParser = undefined;
      }
    }
  }
  return defaultParser;
}

/**
 * Augments the given DOM by adding browser-specific properties and methods (BOM).
 * Returns the augmented DOM.
 */
var browserAugmentation = exports.browserAugmentation = function(dom, options) {

  if (dom._augmented) {
    return dom;
  }

  if(!options) {
    options = {};
  }

  // set up html parser - use a provided one or try and load from library
  var htmltodom = new HtmlToDom(options.parser || getDefaultParser());

  if (!dom.HTMLDocument) {
    dom.HTMLDocument = dom.Document;
  }
  if (!dom.HTMLDocument.prototype.write) {
    dom.HTMLDocument.prototype.write = function(html) {
      this.innerHTML = html;
    };
  }

  dom.Element.prototype.getElementsByClassName = function(className) {

    function filterByClassName(child) {
      if (!child) {
        return false;
      }

      if (child.nodeType &&
          child.nodeType === dom.Node.ENTITY_REFERENCE_NODE)
      {
        child = child._entity;
      }

      var classString = child.className;
      if (classString) {
        var s = classString.split(" ");
        for (var i=0; i<s.length; i++) {
          if (s[i] === className) {
            return true;
          }
        }
      }
      return false;
    }

    return new dom.NodeList(this.ownerDocument || this, dom.mapper(this, filterByClassName));
  };

  dom.Element.prototype.__defineGetter__('sourceIndex', function() {
    /*
    * According to QuirksMode:
    * Get the sourceIndex of element x. This is also the index number for
    * the element in the document.getElementsByTagName('*') array.
    * http://www.quirksmode.org/dom/w3c_core.html#t77
    */
    var items = this.ownerDocument.getElementsByTagName('*'),
        len = items.length;

    for (var i = 0; i < len; i++) {
      if (items[i] === this) {
        return i;
      }
    }
  });

  dom.Document.prototype.__defineGetter__('outerHTML', function() {
    return domToHtml(this);
  });

  dom.Element.prototype.__defineGetter__('outerHTML', function() {
    return domToHtml(this);
  });

  dom.Element.prototype.__defineGetter__('innerHTML', function() {
    return domToHtml(this._childNodes, true);
  });
  dom.Element.prototype.__defineSetter__('doctype', function() {
    throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);
  });
  dom.Element.prototype.__defineGetter__('doctype', function() {
    var r = null;
    if (this.nodeName == '#document') {
        if (this._doctype) {
         r = this._doctype;
        }
    }
    return r;
  });

  dom.Element.prototype.__defineSetter__('innerHTML', function(html) {
    //Check for lib first

    if (html === null) {
      return null;
    }

    //Clear the children first:
    var child;
    while ((child = this._childNodes[0])) {
      this.removeChild(child);
    }

    if (this.nodeName === '#document') {
      parseDocType(this, html);
    }
    var nodes = htmltodom.appendHtmlToElement(html, this);
    return html;
  });


  dom.Document.prototype.__defineGetter__('innerHTML', function() {
    return domToHtml(this._childNodes, true);
  });

  dom.Document.prototype.__defineSetter__('innerHTML', function(html) {
    //Check for lib first

    if (html === null) {
      return null;
    }

    //Clear the children first:
    var child;
    while ((child = this._childNodes[0])) {
      this.removeChild(child);
    }

    if (this.nodeName === '#document') {
      parseDocType(this, html);
    }
    var nodes = htmltodom.appendHtmlToElement(html, this);
    return html;
  });

  var DOC_HTML5      = /<!doctype html>/i,
      DOC_TYPE       = /<!DOCTYPE (\w(.|\n)*)">/i,
      DOC_TYPE_START = '<!DOCTYPE ',
      DOC_TYPE_END   = '">';

  function parseDocType(doc, html) {
    var publicID = '',
        systemID = '',
        fullDT = '',
        name = 'HTML',
        set = true,
        doctype = html.match(DOC_HTML5);

    //Default, No doctype === null
    doc._doctype = null;

    if (doctype && doctype[0]) { //Handle the HTML shorty doctype
      fullDT = doctype[0];
    } else { //Parse the doctype
      // find the start
      var start     = html.indexOf(DOC_TYPE_START),
          end       = html.indexOf(DOC_TYPE_END),
          docString;

      if (start < 0 || end < 0) {
        return;
      }

      docString = html.substr(start, (end-start)+DOC_TYPE_END.length);
      doctype = docString.replace(/[\n\r]/g,'').match(DOC_TYPE);

      if (!doctype) {
        return;
      }

      fullDT = doctype[0];
      doctype = doctype[1].split(' "');
      var _id1 = doctype.length ? doctype.pop().replace(/"/g, '') : '',
          _id2 = doctype.length ? doctype.pop().replace(/"/g, '') : '';

      if (_id1.indexOf('-//') !== -1) {
        publicID = _id1;
      }
      if (_id2.indexOf('-//') !== -1) {
        publicID = _id2;
      }
      if (_id1.indexOf('://') !== -1) {
        systemID = _id1;
      }
      if (_id2.indexOf('://') !== -1) {
        systemID = _id2;
      }
      if (doctype.length) {
        doctype = doctype[0].split(' ');
        name = doctype[0].toUpperCase();
      }
    }
    doc._doctype = new dom.DOMImplementation().createDocumentType(name, publicID, systemID);
    doc._doctype._ownerDocument = doc;
    doc._doctype._fullDT = fullDT;
    doc._doctype.toString = function() {
      return this._fullDT;
    };
  }

  dom.Document.prototype.getElementsByClassName = function(className) {

    function filterByClassName(child) {
      if (!child) {
        return false;
      }

      if (child.nodeType &&
          child.nodeType === dom.Node.ENTITY_REFERENCE_NODE)
      {
        child = child._entity;
      }

      var classString = child.className;
      if (classString) {
        var s = classString.split(" ");
        for (var i=0; i<s.length; i++) {
          if (s[i] === className) {
            return true;
          }
        }
      }
      return false;
    }

    return new dom.NodeList(this.ownerDocument || this, dom.mapper(this, filterByClassName));
  };

  dom.Element.prototype.__defineGetter__('nodeName', function(val) {
    return this._nodeName.toUpperCase();
  });

  dom.Element.prototype.__defineGetter__('tagName', function(val) {
    var t = this._tagName.toUpperCase();
    //Document should not return a tagName
    if (this.nodeName === '#document') {
      t = null;
    }
    return t;
  });

  dom.Element.prototype.scrollTop = 0;
  dom.Element.prototype.scrollLeft = 0;

  dom.Document.prototype.__defineGetter__('parentWindow', function() {
    if (!this._parentWindow) {
      var window = exports.windowAugmentation(dom, {document: this, url: this.URL});
      this._parentWindow = window.getGlobal();
    }
    return this._parentWindow;
  });

  dom.Document.prototype.__defineSetter__('parentWindow', function(window) {
    this._parentWindow = window.getGlobal();
  });

  dom.Document.prototype.__defineGetter__('defaultView', function() {
    return this.parentWindow;
  });

  dom._augmented = true;
  return dom;
};

});

require.define("sys", function (require, module, exports, __dirname, __filename) {
module.exports = require('util');

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/browser/htmltodom.js", function (require, module, exports, __dirname, __filename) {
var HTMLDecode = require('./htmlencoding').HTMLDecode;

function HtmlToDom(parser) {

  if(parser && parser.write) {
    // sax parser
    this.appendHtmlToElement = function(html, element){

      var currentElement = element, currentLevel = 0;

      parser.onerror = function (e) {};

      parser.ontext = function (t) {
        var ownerDocument = currentElement.ownerDocument || currentElement;
        var newText = ownerDocument.createTextNode(t);
        currentElement.appendChild(newText);
      };

      parser.onopentag = function (node) {
        var nodeName  = node.name.toLowerCase(),
            document   = currentElement.ownerDocument || currentElement,
            newElement = document.createElement(nodeName),
            i          = 0,
            length     = (node.attributes && node.attributes.length) ?
                          node.attributes.length                     :
                          0;

        for (i in node.attributes) {
          if (node.attributes.hasOwnProperty(i)) {
            newElement.setAttribute(i, node.attributes[i]);
          }
        }

        for (i=0; i<node.attributes.length; i++) {
            newElement.setAttribute(i, node.attributes.item(i));
        }
        currentElement.appendChild(newElement);
        currentElement = newElement;
      };

      parser.onclosetag = function(node) {
        currentElement = currentElement.parentNode;
      };

      parser.write(html).close();

      return element;
    };

  } else if (parser && (parser.ParseHtml || parser.DefaultHandler)) {

    // Forgiving HTML parser

    if (parser.ParseHtml) {
      // davglass/node-htmlparser
    } else if (parser.DefaultHandler){
      // tautologistics/node-htmlparser

      var handler        = new parser.DefaultHandler(),
          parserInstance = new parser.Parser(handler);
      parser.ParseHtml = function(rawHtml){
        parserInstance.includeLocation = false;
        parserInstance.parseComplete(rawHtml);
        return handler.dom;
      };
    }

    this.appendHtmlToElement = function(html, element) {

      if (typeof html !== 'string') {
        html +='';
      }

      var parsed = parser.ParseHtml(html);

      for (var i = 0; i < parsed.length; i++) {
        setChild(element, parsed[i]);
      }

      return element;
    };

  } else if (parser && parser.moduleName == 'HTML5') { /* HTML5 parser */
    this.appendHtmlToElement = function(html, element) {

      if (typeof html !== 'string') {
        html += '';
      }
      if (html.length > 0) {
        if (element.nodeType == 9) {
          new parser.Parser({document: element}).parse(html);
        }
        else {
          var p = new parser.Parser({document: element.ownerDocument});
          p.parse_fragment(html, element);
          element.appendChild(p.fragment);
        }
      }
    };
  } else {

    this.appendHtmlToElement = function(){
      var sys = require('sys');
      sys.puts('');
      sys.puts('###########################################################');
      sys.puts('#  WARNING: No HTML parser could be found.');
      sys.puts('#  Element.innerHTML setter support has been disabled');
      sys.puts('#  Element.innerHTML getter support will still function');
      sys.puts('#  Download: http://github.com/tautologistics/node-htmlparser');
      sys.puts('###########################################################');
      sys.puts('');
    };

  }
};

// utility function for forgiving parser
function setChild(parent, node) {

  var c, newNode, currentDocument = parent._ownerDocument || parent;

  switch (node.type)
  {
    case 'tag':
    case 'script':
    case 'style':
      try {
        newNode = currentDocument.createElement(node.name);
        if (node.location) {
          newNode.sourceLocation = node.location;
          newNode.sourceLocation.file = parent.sourceLocation.file;
        }
      } catch (err) {
        currentDocument.trigger('error', 'invalid markup', {
          exception: err,
          node : node
        });

        return null;
      }
    break;

    case 'text':
      newNode = currentDocument.createTextNode(HTMLDecode(node.data));
    break;

    case 'comment':
      newNode = currentDocument.createComment(node.data);
    break;

    default:
      return null;
    break;
  }

  if (!newNode)
    return null;

  if (node.attribs) {
    for (c in node.attribs) {
      // catchin errors here helps with improperly escaped attributes
      // but properly fixing parent should (can only?) be done in the htmlparser itself
      try {
        newNode.setAttribute(c.toLowerCase(), HTMLDecode(node.attribs[c]));
      } catch(e2) { /* noop */ }
    }
  }

  if (node.children) {
    for (c = 0; c < node.children.length; c++) {
      setChild(newNode, node.children[c]);
    }
  }

  return parent.appendChild(newNode);
}

exports.HtmlToDom = HtmlToDom;

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/browser/htmlencoding.js", function (require, module, exports, __dirname, __filename) {
var charByEntityName = {
  'quot': '"',
  'amp': '&',
  'apos': '\'',
  'lt': '<',
  'gt': '>',
  'nbsp': ' ',
  'iexcl': '¡',
  'cent': '¢',
  'pound': '£',
  'curren': '¤',
  'yen': '¥',
  'brvbar': '¦',
  'sect': '§',
  'uml': '¨',
  'copy': '©',
  'ordf': 'ª',
  'laquo': '«',
  'not': '¬',
  'shy': '­',
  'reg': '®',
  'macr': '¯', // http://www.w3.org/TR/html4/sgml/entities.html
  'strns': '¯', // http://www.w3.org/TR/html5/named-character-references.html
  'deg': '°',
  'plusmn': '±', // http://www.w3.org/TR/html4/sgml/entities.html
  'pm': '±', // http://www.w3.org/TR/html5/named-character-references.html
  'sup2': '²',
  'sup3': '³',
  'acute': '´',
  'micro': 'µ',
  'para': '¶',
  'middot': '·',
  'cedil': '¸',
  'sup1': '¹',
  'ordm': 'º',
  'raquo': '»',
  'frac14': '¼',
  'half': '½', // http://www.w3.org/TR/html4/sgml/entities.html
  'frac12': '½', // http://www.w3.org/TR/html5/named-character-references.html
  'frac34': '¾',
  'iquest': '¿',
  'Agrave': 'À',
  'Aacute': 'Á',
  'Acirc': 'Â',
  'Atilde': 'Ã',
  'Auml': 'Ä',
  'Aring': 'Å', // http://www.w3.org/TR/html4/sgml/entities.html
  'angst': 'Å', // http://www.w3.org/TR/html5/named-character-references.html
  'AElig': 'Æ',
  'Ccedil': 'Ç',
  'Egrave': 'È',
  'Eacute': 'É',
  'Ecirc': 'Ê',
  'Euml': 'Ë',
  'Igrave': 'Ì',
  'Iacute': 'Í',
  'Icirc': 'Î',
  'Iuml': 'Ï',
  'ETH': 'Ð',
  'Ntilde': 'Ñ',
  'Ograve': 'Ò',
  'Oacute': 'Ó',
  'Ocirc': 'Ô',
  'Otilde': 'Õ',
  'Ouml': 'Ö',
  'times': '×',
  'Oslash': 'Ø',
  'Ugrave': 'Ù',
  'Uacute': 'Ú',
  'Ucirc': 'Û',
  'Uuml': 'Ü',
  'Yacute': 'Ý',
  'THORN': 'Þ',
  'szlig': 'ß',
  'agrave': 'à',
  'aacute': 'á',
  'acirc': 'â',
  'atilde': 'ã',
  'auml': 'ä',
  'aring': 'å',
  'aelig': 'æ',
  'ccedil': 'ç',
  'egrave': 'è',
  'eacute': 'é',
  'ecirc': 'ê',
  'euml': 'ë',
  'igrave': 'ì',
  'iacute': 'í',
  'icirc': 'î',
  'iuml': 'ï',
  'eth': 'ð',
  'ntilde': 'ñ',
  'ograve': 'ò',
  'oacute': 'ó',
  'ocirc': 'ô',
  'otilde': 'õ',
  'ouml': 'ö',
  'divide': '÷',
  'oslash': 'ø',
  'ugrave': 'ù',
  'uacute': 'ú',
  'ucirc': 'û',
  'uuml': 'ü',
  'yacute': 'ý',
  'thorn': 'þ',
  'yuml': 'ÿ',
  'Amacr': 'Ā',
  'amacr': 'ā',
  'Abreve': 'Ă',
  'abreve': 'ă',
  'Aogon': 'Ą',
  'aogon': 'ą',
  'Cacute': 'Ć',
  'cacute': 'ć',
  'Ccirc': 'Ĉ',
  'ccirc': 'ĉ',
  'Cdot': 'Ċ',
  'cdot': 'ċ',
  'Ccaron': 'Č',
  'ccaron': 'č',
  'Dcaron': 'Ď',
  'dcaron': 'ď',
  'Dstrok': 'Đ',
  'dstrok': 'đ',
  'Emacr': 'Ē',
  'emacr': 'ē',
  'Edot': 'Ė',
  'edot': 'ė',
  'Eogon': 'Ę',
  'eogon': 'ę',
  'Ecaron': 'Ě',
  'ecaron': 'ě',
  'Gcirc': 'Ĝ',
  'gcirc': 'ĝ',
  'Gbreve': 'Ğ',
  'gbreve': 'ğ',
  'Gdot': 'Ġ',
  'gdot': 'ġ',
  'Gcedil': 'Ģ',
  'Hcirc': 'Ĥ',
  'hcirc': 'ĥ',
  'Hstrok': 'Ħ',
  'hstrok': 'ħ',
  'Itilde': 'Ĩ',
  'itilde': 'ĩ',
  'Imacr': 'Ī',
  'imacr': 'ī',
  'Iogon': 'Į',
  'iogon': 'į',
  'Idot': 'İ',
  'inodot': 'ı',
  'IJlig': 'Ĳ',
  'ijlig': 'ĳ',
  'Jcirc': 'Ĵ',
  'jcirc': 'ĵ',
  'Kcedil': 'Ķ',
  'kcedil': 'ķ',
  'kgreen': 'ĸ',
  'Lacute': 'Ĺ',
  'lacute': 'ĺ',
  'Lcedil': 'Ļ',
  'lcedil': 'ļ',
  'Lcaron': 'Ľ',
  'lcaron': 'ľ',
  'Lmidot': 'Ŀ',
  'lmidot': 'ŀ',
  'Lstrok': 'Ł',
  'lstrok': 'ł',
  'Nacute': 'Ń',
  'nacute': 'ń',
  'Ncedil': 'Ņ',
  'ncedil': 'ņ',
  'Ncaron': 'Ň',
  'ncaron': 'ň',
  'napos': 'ŉ',
  'ENG': 'Ŋ',
  'eng': 'ŋ',
  'Omacr': 'Ō',
  'omacr': 'ō',
  'Odblac': 'Ő',
  'odblac': 'ő',
  'OElig': 'Œ',
  'oelig': 'œ',
  'Racute': 'Ŕ',
  'racute': 'ŕ',
  'Rcedil': 'Ŗ',
  'rcedil': 'ŗ',
  'Rcaron': 'Ř',
  'rcaron': 'ř',
  'Sacute': 'Ś',
  'sacute': 'ś',
  'Scirc': 'Ŝ',
  'scirc': 'ŝ',
  'Scedil': 'Ş',
  'scedil': 'ş',
  'Scaron': 'Š',
  'scaron': 'š',
  'Tcedil': 'Ţ',
  'tcedil': 'ţ',
  'Tcaron': 'Ť',
  'tcaron': 'ť',
  'Tstrok': 'Ŧ',
  'tstrok': 'ŧ',
  'Utilde': 'Ũ',
  'utilde': 'ũ',
  'Umacr': 'Ū',
  'umacr': 'ū',
  'Ubreve': 'Ŭ',
  'ubreve': 'ŭ',
  'Uring': 'Ů',
  'uring': 'ů',
  'Udblac': 'Ű',
  'udblac': 'ű',
  'Uogon': 'Ų',
  'uogon': 'ų',
  'Wcirc': 'Ŵ',
  'wcirc': 'ŵ',
  'Ycirc': 'Ŷ',
  'ycirc': 'ŷ',
  'Yuml': 'Ÿ',
  'Zacute': 'Ź',
  'zacute': 'ź',
  'Zdot': 'Ż',
  'zdot': 'ż',
  'Zcaron': 'Ž',
  'zcaron': 'ž',
  'fnof': 'ƒ',
  'imped': 'Ƶ',
  'gacute': 'ǵ',
  'jmath': 'ȷ',
  'circ': 'ˆ',
  'caron': 'ˇ',
  'breve': '˘',
  'dot': '˙',
  'ring': '˚',
  'ogon': '˛',
  'tilde': '˜',
  'dblac': '˝',
  'Alpha': 'Α',
  'Beta': 'Β',
  'Gamma': 'Γ',
  'Delta': 'Δ',
  'Epsilon': 'Ε',
  'Zeta': 'Ζ',
  'Eta': 'Η',
  'Theta': 'Θ',
  'Iota': 'Ι',
  'Kappa': 'Κ',
  'Lambda': 'Λ',
  'Mu': 'Μ',
  'Nu': 'Ν',
  'Xi': 'Ξ',
  'Omicron': 'Ο',
  'Pi': 'Π',
  'Rho': 'Ρ',
  'Sigma': 'Σ',
  'Tau': 'Τ',
  'Upsilon': 'Υ',
  'Phi': 'Φ',
  'Chi': 'Χ',
  'Psi': 'Ψ',
  'Omega': 'Ω', // http://www.w3.org/TR/html4/sgml/entities.html
  'ohm': 'Ω', // http://www.w3.org/TR/html5/named-character-references.html
  'alpha': 'α',
  'beta': 'β',
  'gamma': 'γ',
  'delta': 'δ',
  'epsilon': 'ε',
  'zeta': 'ζ',
  'eta': 'η',
  'theta': 'θ',
  'iota': 'ι',
  'kappa': 'κ',
  'lambda': 'λ',
  'mu': 'μ',
  'nu': 'ν',
  'xi': 'ξ',
  'omicron': 'ο',
  'pi': 'π',
  'rho': 'ρ',
  'sigmaf': 'ς', // http://www.w3.org/TR/html4/sgml/entities.html
  'varsigma': 'ς', // http://www.w3.org/TR/html5/named-character-references.html
  'sigma': 'σ',
  'tau': 'τ',
  'upsilon': 'υ',
  'phi': 'φ',
  'chi': 'χ',
  'psi': 'ψ',
  'omega': 'ω',
  'thetasym': 'ϑ', // http://www.w3.org/TR/html4/sgml/entities.html
  'vartheta': 'ϑ', // http://www.w3.org/TR/html5/named-character-references.html
  'upsih': 'ϒ',
  'varphi': 'ϕ',
  'piv': 'ϖ', // http://www.w3.org/TR/html4/sgml/entities.html
  'varpi': 'ϖ', // http://www.w3.org/TR/html5/named-character-references.html
  'Gammad': 'Ϝ',
  'gammad': 'ϝ',
  'varkappa': 'ϰ',
  'varrho': 'ϱ',
  'varepsilon': 'ϵ',
  'bepsi': '϶',
  'IOcy': 'Ё',
  'DJcy': 'Ђ',
  'GJcy': 'Ѓ',
  'Jukcy': 'Є',
  'DScy': 'Ѕ',
  'Iukcy': 'І',
  'YIcy': 'Ї',
  'Jsercy': 'Ј',
  'LJcy': 'Љ',
  'NJcy': 'Њ',
  'TSHcy': 'Ћ',
  'KJcy': 'Ќ',
  'Ubrcy': 'Ў',
  'DZcy': 'Џ',
  'Acy': 'А',
  'Bcy': 'Б',
  'Vcy': 'В',
  'Gcy': 'Г',
  'Dcy': 'Д',
  'IEcy': 'Е',
  'ZHcy': 'Ж',
  'Zcy': 'З',
  'Icy': 'И',
  'Jcy': 'Й',
  'Kcy': 'К',
  'Lcy': 'Л',
  'Mcy': 'М',
  'Ncy': 'Н',
  'Ocy': 'О',
  'Pcy': 'П',
  'Rcy': 'Р',
  'Scy': 'С',
  'Tcy': 'Т',
  'Ucy': 'У',
  'Fcy': 'Ф',
  'KHcy': 'Х',
  'TScy': 'Ц',
  'CHcy': 'Ч',
  'SHcy': 'Ш',
  'SHCHcy': 'Щ',
  'HARDcy': 'Ъ',
  'Ycy': 'Ы',
  'SOFTcy': 'Ь',
  'Ecy': 'Э',
  'YUcy': 'Ю',
  'YAcy': 'Я',
  'acy': 'а',
  'bcy': 'б',
  'vcy': 'в',
  'gcy': 'г',
  'dcy': 'д',
  'iecy': 'е',
  'zhcy': 'ж',
  'zcy': 'з',
  'icy': 'и',
  'jcy': 'й',
  'kcy': 'к',
  'lcy': 'л',
  'mcy': 'м',
  'ncy': 'н',
  'ocy': 'о',
  'pcy': 'п',
  'rcy': 'р',
  'scy': 'с',
  'tcy': 'т',
  'ucy': 'у',
  'fcy': 'ф',
  'khcy': 'х',
  'tscy': 'ц',
  'chcy': 'ч',
  'shcy': 'ш',
  'shchcy': 'щ',
  'hardcy': 'ъ',
  'ycy': 'ы',
  'softcy': 'ь',
  'ecy': 'э',
  'yucy': 'ю',
  'yacy': 'я',
  'iocy': 'ё',
  'djcy': 'ђ',
  'gjcy': 'ѓ',
  'jukcy': 'є',
  'dscy': 'ѕ',
  'iukcy': 'і',
  'yicy': 'ї',
  'jsercy': 'ј',
  'ljcy': 'љ',
  'njcy': 'њ',
  'tshcy': 'ћ',
  'kjcy': 'ќ',
  'ubrcy': 'ў',
  'dzcy': 'џ',
  'ensp': ' ',
  'emsp': ' ',
  'emsp13': ' ',
  'emsp14': ' ',
  'numsp': ' ',
  'puncsp': ' ',
  'thinsp': ' ',
  'hairsp': ' ',
  'ZeroWidthSpace': '​',
  'zwnj': '‌',
  'zwj': '‍',
  'lrm': '‎',
  'rlm': '‏',
  'hyphen': '‐',
  'ndash': '–',
  'mdash': '—',
  'horbar': '―',
  'Vert': '‖',
  'lsquo': '‘',
  'rsquo': '’', // http://www.w3.org/TR/html4/sgml/entities.html
  'rsquor': '’', // http://www.w3.org/TR/html5/named-character-references.html
  'sbquo': '‚',
  'ldquo': '“',
  'rdquo': '”', // http://www.w3.org/TR/html4/sgml/entities.html
  'rdquor': '”', // http://www.w3.org/TR/html5/named-character-references.html
  'ldquo': '„', // http://www.w3.org/TR/html4/sgml/entities.html
  'ldquor': '„', // http://www.w3.org/TR/html5/named-character-references.html
  'dagger': '†',
  'Dagger': '‡', // http://www.w3.org/TR/html4/sgml/entities.html
  'ddagger': '‡', // http://www.w3.org/TR/html5/named-character-references.html
  'bull': '•', // http://www.w3.org/TR/html4/sgml/entities.html
  'bullet': '•', // http://www.w3.org/TR/html5/named-character-references.html
  'nldr': '‥',
  'hellip': '…', // http://www.w3.org/TR/html4/sgml/entities.html
  'mldr': '…', // http://www.w3.org/TR/html5/named-character-references.html
  'permil': '‰',
  'pertenk': '‱',
  'prime': '′',
  'Prime': '″',
  'tprime': '‴',
  'bprime': '‵',
  'lsaquo': '‹',
  'rsaquo': '›',
  'oline': '‾',
  'caret': '⁁',
  'hybull': '⁃',
  'frasl': '⁄',
  'bsemi': '⁏',
  'qprime': '⁗',
  'MediumSpace': ' ',
  'NoBreak': '⁠',
  'af': '⁡',
  'it': '⁢',
  'ic': '⁣',
  'euro': '€',
  'complexes': 'ℂ',
  'incare': '℅',
  'gscr': 'ℊ',
  'hamilt': 'ℋ',
  'Poincareplane': 'ℌ',
  'quaternions': 'ℍ',
  'planckh': 'ℎ',
  'plankv': 'ℏ',
  'imagline': 'ℐ',
  'image': 'ℑ', // http://www.w3.org/TR/html4/sgml/entities.html
  'imagpart': 'ℑ', // http://www.w3.org/TR/html5/named-character-references.html
  'lagran': 'ℒ',
  'ell': 'ℓ',
  'naturals': 'ℕ',
  'numero': '№',
  'copysr': '℗',
  'weierp': '℘', // http://www.w3.org/TR/html4/sgml/entities.html
  'wp': '℘', // http://www.w3.org/TR/html5/named-character-references.html
  'primes': 'ℙ',
  'rationals': 'ℚ',
  'realine': 'ℛ',
  'real': 'ℜ', // http://www.w3.org/TR/html4/sgml/entities.html
  'realpart': 'ℜ', // http://www.w3.org/TR/html5/named-character-references.html
  'reals': 'ℝ',
  'rx': '℞',
  'trade': '™',
  'integers': 'ℤ',
  'mho': '℧',
  'zeetrf': 'ℨ',
  'iiota': '℩',
  'bernou': 'ℬ',
  'Cfr': 'ℭ',
  'escr': 'ℯ',
  'expectation': 'ℰ',
  'Fscr': 'ℱ',
  'phmmat': 'ℳ',
  'oscr': 'ℴ',
  'alefsym': 'ℵ', // http://www.w3.org/TR/html4/sgml/entities.html
  'aleph': 'ℵ', // http://www.w3.org/TR/html5/named-character-references.html
  'beth': 'ℶ',
  'gimel': 'ℷ',
  'daleth': 'ℸ',
  'DD': 'ⅅ',
  'dd': 'ⅆ',
  'exponentiale': 'ⅇ',
  'ii': 'ⅈ',
  'frac13': '⅓',
  'frac23': '⅔',
  'frac15': '⅕',
  'frac25': '⅖',
  'frac35': '⅗',
  'frac45': '⅘',
  'frac16': '⅙',
  'frac56': '⅚',
  'frac18': '⅛',
  'frac38': '⅜',
  'frac58': '⅝',
  'frac78': '⅞',
  'larr': '←', // http://www.w3.org/TR/html4/sgml/entities.html
  'slarr': '←', // http://www.w3.org/TR/html5/named-character-references.html
  'uarr': '↑', // http://www.w3.org/TR/html4/sgml/entities.html
  'uparrow': '↑', // http://www.w3.org/TR/html5/named-character-references.html
  'rarr': '→', // http://www.w3.org/TR/html4/sgml/entities.html
  'srarr': '→', // http://www.w3.org/TR/html5/named-character-references.html
  'darr': '↓', // http://www.w3.org/TR/html4/sgml/entities.html
  'downarrow': '↓', // http://www.w3.org/TR/html5/named-character-references.html
  'harr': '↔', // http://www.w3.org/TR/html4/sgml/entities.html
  'leftrightarrow': '↔', // http://www.w3.org/TR/html5/named-character-references.html
  'varr': '↕',
  'nwarrow': '↖',
  'nearrow': '↗',
  'searrow': '↘',
  'swarrow': '↙',
  'nleftarrow': '↚',
  'nrightarrow': '↛',
  'rightsquigarrow': '↝',
  'twoheadleftarrow': '↞',
  'Uarr': '↟',
  'twoheadrightarrow': '↠',
  'Darr': '↡',
  'leftarrowtail': '↢',
  'rightarrowtail': '↣',
  'mapstoleft': '↤',
  'mapstoup': '↥',
  'mapsto': '↦',
  'mapstodown': '↧',
  'larrhk': '↩',
  'rarrhk': '↪',
  'looparrowleft': '↫',
  'rarrlp': '↬',
  'leftrightsquigarrow': '↭',
  'nleftrightarrow': '↮',
  'lsh': '↰',
  'rsh': '↱',
  'ldsh': '↲',
  'rdsh': '↳',
  'crarr': '↵',
  'curvearrowleft': '↶',
  'curvearrowright': '↷',
  'olarr': '↺',
  'orarr': '↻',
  'lharu': '↼',
  'lhard': '↽',
  'upharpoonright': '↾',
  'upharpoonleft': '↿',
  'rightharpoonup': '⇀',
  'rightharpoondown': '⇁',
  'downharpoonright': '⇂',
  'downharpoonleft': '⇃',
  'rlarr': '⇄',
  'udarr': '⇅',
  'lrarr': '⇆',
  'llarr': '⇇',
  'uuarr': '⇈',
  'rrarr': '⇉',
  'downdownarrows': '⇊',
  'lrhar': '⇋',
  'rlhar': '⇌',
  'nlArr': '⇍',
  'nhArr': '⇎',
  'nrArr': '⇏',
  'lArr': '⇐',
  'uArr': '⇑',
  'rArr': '⇒',
  'dArr': '⇓',
  'hArr': '⇔', // http://www.w3.org/TR/html4/sgml/entities.html
  'iff': '⇔', // http://www.w3.org/TR/html5/named-character-references.html
  'vArr': '⇕',
  'nwArr': '⇖',
  'neArr': '⇗',
  'seArr': '⇘',
  'swArr': '⇙',
  'lAarr': '⇚',
  'rAarr': '⇛',
  'zigrarr': '⇝',
  'larrb': '⇤',
  'rarrb': '⇥',
  'duarr': '⇵',
  'loarr': '⇽',
  'roarr': '⇾',
  'hoarr': '⇿',
  'forall': '∀',
  'complement': '∁',
  'part': '∂',
  'exist': '∃',
  'nexists': '∄',
  'empty': '∅', // http://www.w3.org/TR/html4/sgml/entities.html
  'varnothing': '∅', // http://www.w3.org/TR/html5/named-character-references.html
  'nabla': '∇',
  'isin': '∈', // http://www.w3.org/TR/html4/sgml/entities.html
  'isinv': '∈', // http://www.w3.org/TR/html5/named-character-references.html
  'notin': '∉', // http://www.w3.org/TR/html4/sgml/entities.html
  'notinva': '∉', // http://www.w3.org/TR/html5/named-character-references.html
  'ni': '∋', // http://www.w3.org/TR/html4/sgml/entities.html
  'niv': '∋', // http://www.w3.org/TR/html5/named-character-references.html
  'notniva': '∌',
  'prod': '∏',
  'coprod': '∐',
  'sum': '∑',
  'minus': '−',
  'mp': '∓',
  'plusdo': '∔',
  'ssetmn': '∖',
  'lowast': '∗',
  'compfn': '∘',
  'radic': '√',
  'prop': '∝', // http://www.w3.org/TR/html4/sgml/entities.html
  'vprop': '∝', // http://www.w3.org/TR/html5/named-character-references.html
  'infin': '∞',
  'angrt': '∟',
  'ang': '∠', // http://www.w3.org/TR/html4/sgml/entities.html
  'angle': '∠', // http://www.w3.org/TR/html5/named-character-references.html
  'measuredangle': '∡',
  'angsph': '∢',
  'smid': '∣',
  'nsmid': '∤',
  'spar': '∥',
  'nspar': '∦',
  'and': '∧', // http://www.w3.org/TR/html4/sgml/entities.html
  'wedge': '∧', // http://www.w3.org/TR/html5/named-character-references.html
  'or': '∨', // http://www.w3.org/TR/html4/sgml/entities.html
  'vee': '∨', // http://www.w3.org/TR/html5/named-character-references.html
  'cap': '∩',
  'cup': '∪',
  'int': '∫',
  'Int': '∬',
  'tint': '∭',
  'oint': '∮',
  'DoubleContourIntegral': '∯',
  'Cconint': '∰',
  'cwint': '∱',
  'cwconint': '∲',
  'awconint': '∳',
  'there4': '∴', // http://www.w3.org/TR/html4/sgml/entities.html
  'therefore': '∴', // http://www.w3.org/TR/html5/named-character-references.html
  'because': '∵',
  'ratio': '∶',
  'Proportion': '∷',
  'minusd': '∸',
  'mDDot': '∺',
  'homtht': '∻',
  'sim': '∼', // http://www.w3.org/TR/html4/sgml/entities.html
  'thksim': '∼', // http://www.w3.org/TR/html5/named-character-references.html
  'bsim': '∽',
  'mstpos': '∾',
  'acd': '∿',
  'wreath': '≀',
  'nsim': '≁',
  'esim': '≂',
  'simeq': '≃',
  'nsimeq': '≄',
  'cong': '≅',
  'simne': '≆',
  'ncong': '≇',
  'asymp': '≈', // http://www.w3.org/TR/html4/sgml/entities.html
  'thkap': '≈', // http://www.w3.org/TR/html5/named-character-references.html
  'napprox': '≉',
  'approxeq': '≊',
  'apid': '≋',
  'bcong': '≌',
  'asympeq': '≍',
  'bump': '≎',
  'bumpeq': '≏',
  'esdot': '≐',
  'eDot': '≑',
  'fallingdotseq': '≒',
  'risingdotseq': '≓',
  'coloneq': '≔',
  'eqcolon': '≕',
  'eqcirc': '≖',
  'cire': '≗',
  'wedgeq': '≙',
  'veeeq': '≚',
  'trie': '≜',
  'questeq': '≟',
  'ne': '≠',
  'equiv': '≡',
  'nequiv': '≢',
  'le': '≤', // http://www.w3.org/TR/html4/sgml/entities.html
  'leq': '≤', // http://www.w3.org/TR/html5/named-character-references.html
  'ge': '≥', // http://www.w3.org/TR/html4/sgml/entities.html
  'geq': '≥', // http://www.w3.org/TR/html5/named-character-references.html
  'leqq': '≦',
  'geqq': '≧',
  'lneqq': '≨',
  'gneqq': '≩',
  'll': '≪',
  'gg': '≫',
  'twixt': '≬',
  'NotCupCap': '≭',
  'nlt': '≮',
  'ngtr': '≯',
  'nleq': '≰',
  'ngeq': '≱',
  'lsim': '≲',
  'gtrsim': '≳',
  'nlsim': '≴',
  'ngsim': '≵',
  'lg': '≶',
  'gtrless': '≷',
  'ntlg': '≸',
  'ntgl': '≹',
  'prec': '≺',
  'succ': '≻',
  'preccurlyeq': '≼',
  'succcurlyeq': '≽',
  'prsim': '≾',
  'succsim': '≿',
  'nprec': '⊀',
  'nsucc': '⊁',
  'sub': '⊂', // http://www.w3.org/TR/html4/sgml/entities.html
  'subset': '⊂', // http://www.w3.org/TR/html5/named-character-references.html
  'sup': '⊃', // http://www.w3.org/TR/html4/sgml/entities.html
  'supset': '⊃', // http://www.w3.org/TR/html5/named-character-references.html
  'nsub': '⊄',
  'nsup': '⊅',
  'sube': '⊆', // http://www.w3.org/TR/html4/sgml/entities.html
  'subseteq': '⊆', // http://www.w3.org/TR/html5/named-character-references.html
  'supe': '⊇', // http://www.w3.org/TR/html4/sgml/entities.html
  'supseteq': '⊇', // http://www.w3.org/TR/html5/named-character-references.html
  'nsubseteq': '⊈',
  'nsupseteq': '⊉',
  'subsetneq': '⊊',
  'supsetneq': '⊋',
  'cupdot': '⊍',
  'uplus': '⊎',
  'sqsubset': '⊏',
  'sqsupset': '⊐',
  'sqsubseteq': '⊑',
  'sqsupseteq': '⊒',
  'sqcap': '⊓',
  'sqcup': '⊔',
  'oplus': '⊕',
  'ominus': '⊖',
  'otimes': '⊗',
  'osol': '⊘',
  'odot': '⊙',
  'ocir': '⊚',
  'oast': '⊛',
  'odash': '⊝',
  'plusb': '⊞',
  'minusb': '⊟',
  'timesb': '⊠',
  'sdotb': '⊡',
  'vdash': '⊢',
  'dashv': '⊣',
  'top': '⊤',
  'perp': '⊥',
  'models': '⊧',
  'vDash': '⊨',
  'Vdash': '⊩',
  'Vvdash': '⊪',
  'VDash': '⊫',
  'nvdash': '⊬',
  'nvDash': '⊭',
  'nVdash': '⊮',
  'nVDash': '⊯',
  'prurel': '⊰',
  'vltri': '⊲',
  'vrtri': '⊳',
  'trianglelefteq': '⊴',
  'trianglerighteq': '⊵',
  'origof': '⊶',
  'imof': '⊷',
  'mumap': '⊸',
  'hercon': '⊹',
  'intercal': '⊺',
  'veebar': '⊻',
  'barvee': '⊽',
  'angrtvb': '⊾',
  'lrtri': '⊿',
  'xwedge': '⋀',
  'xvee': '⋁',
  'xcap': '⋂',
  'xcup': '⋃',
  'diamond': '⋄',
  'sdot': '⋅',
  'sstarf': '⋆',
  'divonx': '⋇',
  'bowtie': '⋈',
  'ltimes': '⋉',
  'rtimes': '⋊',
  'lthree': '⋋',
  'rthree': '⋌',
  'bsime': '⋍',
  'cuvee': '⋎',
  'cuwed': '⋏',
  'Subset': '⋐',
  'Supset': '⋑',
  'Cap': '⋒',
  'Cup': '⋓',
  'pitchfork': '⋔',
  'epar': '⋕',
  'ltdot': '⋖',
  'gtrdot': '⋗',
  'Ll': '⋘',
  'ggg': '⋙',
  'lesseqgtr': '⋚',
  'gtreqless': '⋛',
  'curlyeqprec': '⋞',
  'curlyeqsucc': '⋟',
  'nprcue': '⋠',
  'nsccue': '⋡',
  'nsqsube': '⋢',
  'nsqsupe': '⋣',
  'lnsim': '⋦',
  'gnsim': '⋧',
  'prnsim': '⋨',
  'succnsim': '⋩',
  'ntriangleleft': '⋪',
  'ntriangleright': '⋫',
  'ntrianglelefteq': '⋬',
  'ntrianglerighteq': '⋭',
  'vellip': '⋮',
  'ctdot': '⋯',
  'utdot': '⋰',
  'dtdot': '⋱',
  'disin': '⋲',
  'isinsv': '⋳',
  'isins': '⋴',
  'isindot': '⋵',
  'notinvc': '⋶',
  'notinvb': '⋷',
  'isinE': '⋹',
  'nisd': '⋺',
  'xnis': '⋻',
  'nis': '⋼',
  'notnivc': '⋽',
  'notnivb': '⋾',
  'barwedge': '⌅',
  'doublebarwedge': '⌆',
  'lceil': '⌈',
  'rceil': '⌉',
  'lfloor': '⌊',
  'rfloor': '⌋',
  'drcrop': '⌌',
  'dlcrop': '⌍',
  'urcrop': '⌎',
  'ulcrop': '⌏',
  'bnot': '⌐',
  'profline': '⌒',
  'profsurf': '⌓',
  'telrec': '⌕',
  'target': '⌖',
  'ulcorner': '⌜',
  'urcorner': '⌝',
  'llcorner': '⌞',
  'lrcorner': '⌟',
  'sfrown': '⌢',
  'ssmile': '⌣',
  'lang': '〈', // http://www.w3.org/TR/html4/sgml/entities.html
  'rang': '〉', // http://www.w3.org/TR/html4/sgml/entities.html
  'cylcty': '⌭',
  'profalar': '⌮',
  'topbot': '⌶',
  'ovbar': '⌽',
  'solbar': '⌿',
  'angzarr': '⍼',
  'lmoustache': '⎰',
  'rmoustache': '⎱',
  'tbrk': '⎴',
  'bbrk': '⎵',
  'bbrktbrk': '⎶',
  'OverParenthesis': '⏜',
  'UnderParenthesis': '⏝',
  'OverBrace': '⏞',
  'UnderBrace': '⏟',
  'trpezium': '⏢',
  'elinters': '⏧',
  'blank': '␣',
  'oS': 'Ⓢ',
  'boxh': '─',
  'boxv': '│',
  'boxdr': '┌',
  'boxdl': '┐',
  'boxur': '└',
  'boxul': '┘',
  'boxvr': '├',
  'boxvl': '┤',
  'boxhd': '┬',
  'boxhu': '┴',
  'boxvh': '┼',
  'boxH': '═',
  'boxV': '║',
  'boxdR': '╒',
  'boxDr': '╓',
  'boxDR': '╔',
  'boxdL': '╕',
  'boxDl': '╖',
  'boxDL': '╗',
  'boxuR': '╘',
  'boxUr': '╙',
  'boxUR': '╚',
  'boxuL': '╛',
  'boxUl': '╜',
  'boxUL': '╝',
  'boxvR': '╞',
  'boxVr': '╟',
  'boxVR': '╠',
  'boxvL': '╡',
  'boxVl': '╢',
  'boxVL': '╣',
  'boxHd': '╤',
  'boxhD': '╥',
  'boxHD': '╦',
  'boxHu': '╧',
  'boxhU': '╨',
  'boxHU': '╩',
  'boxvH': '╪',
  'boxVh': '╫',
  'boxVH': '╬',
  'uhblk': '▀',
  'lhblk': '▄',
  'block': '█',
  'blk14': '░',
  'blk12': '▒',
  'blk34': '▓',
  'square': '□',
  'squf': '▪',
  'EmptyVerySmallSquare': '▫',
  'rect': '▭',
  'marker': '▮',
  'fltns': '▱',
  'xutri': '△',
  'utrif': '▴',
  'utri': '▵',
  'rtrif': '▸',
  'triangleright': '▹',
  'xdtri': '▽',
  'dtrif': '▾',
  'triangledown': '▿',
  'ltrif': '◂',
  'triangleleft': '◃',
  'loz': '◊', // http://www.w3.org/TR/html4/sgml/entities.html
  'lozenge': '◊', // http://www.w3.org/TR/html5/named-character-references.html
  'cir': '○',
  'tridot': '◬',
  'xcirc': '◯',
  'ultri': '◸',
  'urtri': '◹',
  'lltri': '◺',
  'EmptySmallSquare': '◻',
  'FilledSmallSquare': '◼',
  'starf': '★',
  'star': '☆',
  'phone': '☎',
  'female': '♀',
  'male': '♂',
  'spades': '♠', // http://www.w3.org/TR/html4/sgml/entities.html
  'spadesuit': '♠', // http://www.w3.org/TR/html5/named-character-references.html
  'clubs': '♣', // http://www.w3.org/TR/html4/sgml/entities.html
  'clubsuit': '♣', // http://www.w3.org/TR/html5/named-character-references.html
  'hearts': '♥', // http://www.w3.org/TR/html4/sgml/entities.html
  'heartsuit': '♥', // http://www.w3.org/TR/html5/named-character-references.html
  'diams': '♦',
  'sung': '♪',
  'flat': '♭',
  'natural': '♮',
  'sharp': '♯',
  'checkmark': '✓',
  'cross': '✗',
  'maltese': '✠',
  'sext': '✶',
  'VerticalSeparator': '❘',
  'lbbrk': '❲',
  'rbbrk': '❳',
  'bsolhsub': '⟈',
  'suphsol': '⟉',
  'lobrk': '⟦',
  'robrk': '⟧',
  'langle': '⟨',
  'rangle': '⟩',
  'Lang': '⟪',
  'Rang': '⟫',
  'loang': '⟬',
  'roang': '⟭',
  'xlarr': '⟵',
  'xrarr': '⟶',
  'xharr': '⟷',
  'xlArr': '⟸',
  'xrArr': '⟹',
  'xhArr': '⟺',
  'xmap': '⟼',
  'dzigrarr': '⟿',
  'nvlArr': '⤂',
  'nvrArr': '⤃',
  'nvHarr': '⤄',
  'Map': '⤅',
  'lbarr': '⤌',
  'rbarr': '⤍',
  'lBarr': '⤎',
  'rBarr': '⤏',
  'drbkarow': '⤐',
  'DDotrahd': '⤑',
  'UpArrowBar': '⤒',
  'DownArrowBar': '⤓',
  'Rarrtl': '⤖',
  'latail': '⤙',
  'ratail': '⤚',
  'lAtail': '⤛',
  'rAtail': '⤜',
  'larrfs': '⤝',
  'rarrfs': '⤞',
  'larrbfs': '⤟',
  'rarrbfs': '⤠',
  'nwarhk': '⤣',
  'nearhk': '⤤',
  'searhk': '⤥',
  'swarhk': '⤦',
  'nwnear': '⤧',
  'toea': '⤨',
  'tosa': '⤩',
  'swnwar': '⤪',
  'rarrc': '⤳',
  'cudarrr': '⤵',
  'ldca': '⤶',
  'rdca': '⤷',
  'cudarrl': '⤸',
  'larrpl': '⤹',
  'curarrm': '⤼',
  'cularrp': '⤽',
  'rarrpl': '⥅',
  'harrcir': '⥈',
  'Uarrocir': '⥉',
  'lurdshar': '⥊',
  'ldrushar': '⥋',
  'LeftRightVector': '⥎',
  'RightUpDownVector': '⥏',
  'DownLeftRightVector': '⥐',
  'LeftUpDownVector': '⥑',
  'LeftVectorBar': '⥒',
  'RightVectorBar': '⥓',
  'RightUpVectorBar': '⥔',
  'RightDownVectorBar': '⥕',
  'DownLeftVectorBar': '⥖',
  'DownRightVectorBar': '⥗',
  'LeftUpVectorBar': '⥘',
  'LeftDownVectorBar': '⥙',
  'LeftTeeVector': '⥚',
  'RightTeeVector': '⥛',
  'RightUpTeeVector': '⥜',
  'RightDownTeeVector': '⥝',
  'DownLeftTeeVector': '⥞',
  'DownRightTeeVector': '⥟',
  'LeftUpTeeVector': '⥠',
  'LeftDownTeeVector': '⥡',
  'lHar': '⥢',
  'uHar': '⥣',
  'rHar': '⥤',
  'dHar': '⥥',
  'luruhar': '⥦',
  'ldrdhar': '⥧',
  'ruluhar': '⥨',
  'rdldhar': '⥩',
  'lharul': '⥪',
  'llhard': '⥫',
  'rharul': '⥬',
  'lrhard': '⥭',
  'udhar': '⥮',
  'duhar': '⥯',
  'RoundImplies': '⥰',
  'erarr': '⥱',
  'simrarr': '⥲',
  'larrsim': '⥳',
  'rarrsim': '⥴',
  'rarrap': '⥵',
  'ltlarr': '⥶',
  'gtrarr': '⥸',
  'subrarr': '⥹',
  'suplarr': '⥻',
  'lfisht': '⥼',
  'rfisht': '⥽',
  'ufisht': '⥾',
  'dfisht': '⥿',
  'lopar': '⦅',
  'ropar': '⦆',
  'lbrke': '⦋',
  'rbrke': '⦌',
  'lbrkslu': '⦍',
  'rbrksld': '⦎',
  'lbrksld': '⦏',
  'rbrkslu': '⦐',
  'langd': '⦑',
  'rangd': '⦒',
  'lparlt': '⦓',
  'rpargt': '⦔',
  'gtlPar': '⦕',
  'ltrPar': '⦖',
  'vzigzag': '⦚',
  'vangrt': '⦜',
  'angrtvbd': '⦝',
  'ange': '⦤',
  'range': '⦥',
  'dwangle': '⦦',
  'uwangle': '⦧',
  'angmsdaa': '⦨',
  'angmsdab': '⦩',
  'angmsdac': '⦪',
  'angmsdad': '⦫',
  'angmsdae': '⦬',
  'angmsdaf': '⦭',
  'angmsdag': '⦮',
  'angmsdah': '⦯',
  'bemptyv': '⦰',
  'demptyv': '⦱',
  'cemptyv': '⦲',
  'raemptyv': '⦳',
  'laemptyv': '⦴',
  'ohbar': '⦵',
  'omid': '⦶',
  'opar': '⦷',
  'operp': '⦹',
  'olcross': '⦻',
  'odsold': '⦼',
  'olcir': '⦾',
  'ofcir': '⦿',
  'olt': '⧀',
  'ogt': '⧁',
  'cirscir': '⧂',
  'cirE': '⧃',
  'solb': '⧄',
  'bsolb': '⧅',
  'boxbox': '⧉',
  'trisb': '⧍',
  'rtriltri': '⧎',
  'LeftTriangleBar': '⧏',
  'RightTriangleBar': '⧐',
  'iinfin': '⧜',
  'infintie': '⧝',
  'nvinfin': '⧞',
  'eparsl': '⧣',
  'smeparsl': '⧤',
  'eqvparsl': '⧥',
  'lozf': '⧫',
  'RuleDelayed': '⧴',
  'dsol': '⧶',
  'xodot': '⨀',
  'xoplus': '⨁',
  'xotime': '⨂',
  'xuplus': '⨄',
  'xsqcup': '⨆',
  'qint': '⨌',
  'fpartint': '⨍',
  'cirfnint': '⨐',
  'awint': '⨑',
  'rppolint': '⨒',
  'scpolint': '⨓',
  'npolint': '⨔',
  'pointint': '⨕',
  'quatint': '⨖',
  'intlarhk': '⨗',
  'pluscir': '⨢',
  'plusacir': '⨣',
  'simplus': '⨤',
  'plusdu': '⨥',
  'plussim': '⨦',
  'plustwo': '⨧',
  'mcomma': '⨩',
  'minusdu': '⨪',
  'loplus': '⨭',
  'roplus': '⨮',
  'Cross': '⨯',
  'timesd': '⨰',
  'timesbar': '⨱',
  'smashp': '⨳',
  'lotimes': '⨴',
  'rotimes': '⨵',
  'otimesas': '⨶',
  'Otimes': '⨷',
  'odiv': '⨸',
  'triplus': '⨹',
  'triminus': '⨺',
  'tritime': '⨻',
  'iprod': '⨼',
  'amalg': '⨿',
  'capdot': '⩀',
  'ncup': '⩂',
  'ncap': '⩃',
  'capand': '⩄',
  'cupor': '⩅',
  'cupcap': '⩆',
  'capcup': '⩇',
  'cupbrcap': '⩈',
  'capbrcup': '⩉',
  'cupcup': '⩊',
  'capcap': '⩋',
  'ccups': '⩌',
  'ccaps': '⩍',
  'ccupssm': '⩐',
  'And': '⩓',
  'Or': '⩔',
  'andand': '⩕',
  'oror': '⩖',
  'orslope': '⩗',
  'andslope': '⩘',
  'andv': '⩚',
  'orv': '⩛',
  'andd': '⩜',
  'ord': '⩝',
  'wedbar': '⩟',
  'sdote': '⩦',
  'simdot': '⩪',
  'congdot': '⩭',
  'easter': '⩮',
  'apacir': '⩯',
  'apE': '⩰',
  'eplus': '⩱',
  'pluse': '⩲',
  'Esim': '⩳',
  'Colone': '⩴',
  'Equal': '⩵',
  'eDDot': '⩷',
  'equivDD': '⩸',
  'ltcir': '⩹',
  'gtcir': '⩺',
  'ltquest': '⩻',
  'gtquest': '⩼',
  'les': '⩽',
  'ges': '⩾',
  'lesdot': '⩿',
  'gesdot': '⪀',
  'lesdoto': '⪁',
  'gesdoto': '⪂',
  'lesdotor': '⪃',
  'gesdotol': '⪄',
  'lessapprox': '⪅',
  'gtrapprox': '⪆',
  'lneq': '⪇',
  'gneq': '⪈',
  'lnapprox': '⪉',
  'gnapprox': '⪊',
  'lesseqqgtr': '⪋',
  'gtreqqless': '⪌',
  'lsime': '⪍',
  'gsime': '⪎',
  'lsimg': '⪏',
  'gsiml': '⪐',
  'lgE': '⪑',
  'glE': '⪒',
  'lesges': '⪓',
  'gesles': '⪔',
  'eqslantless': '⪕',
  'eqslantgtr': '⪖',
  'elsdot': '⪗',
  'egsdot': '⪘',
  'el': '⪙',
  'eg': '⪚',
  'siml': '⪝',
  'simg': '⪞',
  'simlE': '⪟',
  'simgE': '⪠',
  'LessLess': '⪡',
  'GreaterGreater': '⪢',
  'glj': '⪤',
  'gla': '⪥',
  'ltcc': '⪦',
  'gtcc': '⪧',
  'lescc': '⪨',
  'gescc': '⪩',
  'smt': '⪪',
  'lat': '⪫',
  'smte': '⪬',
  'late': '⪭',
  'bumpE': '⪮',
  'preceq': '⪯',
  'succeq': '⪰',
  'prE': '⪳',
  'scE': '⪴',
  'prnE': '⪵',
  'succneqq': '⪶',
  'precapprox': '⪷',
  'succapprox': '⪸',
  'prnap': '⪹',
  'succnapprox': '⪺',
  'Pr': '⪻',
  'Sc': '⪼',
  'subdot': '⪽',
  'supdot': '⪾',
  'subplus': '⪿',
  'supplus': '⫀',
  'submult': '⫁',
  'supmult': '⫂',
  'subedot': '⫃',
  'supedot': '⫄',
  'subseteqq': '⫅',
  'supseteqq': '⫆',
  'subsim': '⫇',
  'supsim': '⫈',
  'subsetneqq': '⫋',
  'supsetneqq': '⫌',
  'csub': '⫏',
  'csup': '⫐',
  'csube': '⫑',
  'csupe': '⫒',
  'subsup': '⫓',
  'supsub': '⫔',
  'subsub': '⫕',
  'supsup': '⫖',
  'suphsub': '⫗',
  'supdsub': '⫘',
  'forkv': '⫙',
  'topfork': '⫚',
  'mlcp': '⫛',
  'DoubleLeftTee': '⫤',
  'Vdashl': '⫦',
  'Barv': '⫧',
  'vBar': '⫨',
  'vBarv': '⫩',
  'Vbar': '⫫',
  'Not': '⫬',
  'bNot': '⫭',
  'rnmid': '⫮',
  'cirmid': '⫯',
  'midcir': '⫰',
  'topcir': '⫱',
  'nhpar': '⫲',
  'parsim': '⫳',
  'parsl': '⫽',
  'fflig': 'ﬀ',
  'filig': 'ﬁ',
  'fllig': 'ﬂ',
  'ffilig': 'ﬃ',
  'ffllig': 'ﬄ',
  'Ascr': '풜',
  'Cscr': '풞',
  'Dscr': '풟',
  'Gscr': '풢',
  'Jscr': '풥',
  'Kscr': '풦',
  'Nscr': '풩',
  'Oscr': '풪',
  'Pscr': '풫',
  'Qscr': '풬',
  'Sscr': '풮',
  'Tscr': '풯',
  'Uscr': '풰',
  'Vscr': '풱',
  'Wscr': '풲',
  'Xscr': '풳',
  'Yscr': '풴',
  'Zscr': '풵',
  'ascr': '풶',
  'bscr': '풷',
  'cscr': '풸',
  'dscr': '풹',
  'fscr': '풻',
  'hscr': '풽',
  'iscr': '풾',
  'jscr': '풿',
  'kscr': '퓀',
  'lscr': '퓁',
  'mscr': '퓂',
  'nscr': '퓃',
  'pscr': '퓅',
  'qscr': '퓆',
  'rscr': '퓇',
  'sscr': '퓈',
  'tscr': '퓉',
  'uscr': '퓊',
  'vscr': '퓋',
  'wscr': '퓌',
  'xscr': '퓍',
  'yscr': '퓎',
  'zscr': '퓏',
  'Afr': '프',
  'Bfr': '픅',
  'Dfr': '픇',
  'Efr': '픈',
  'Ffr': '픉',
  'Gfr': '픊',
  'Jfr': '픍',
  'Kfr': '픎',
  'Lfr': '픏',
  'Mfr': '픐',
  'Nfr': '픑',
  'Ofr': '픒',
  'Pfr': '픓',
  'Qfr': '픔',
  'Sfr': '픖',
  'Tfr': '픗',
  'Ufr': '픘',
  'Vfr': '픙',
  'Wfr': '픚',
  'Xfr': '픛',
  'Yfr': '픜',
  'afr': '픞',
  'bfr': '픟',
  'cfr': '픠',
  'dfr': '픡',
  'efr': '픢',
  'ffr': '픣',
  'gfr': '픤',
  'hfr': '픥',
  'ifr': '픦',
  'jfr': '픧',
  'kfr': '픨',
  'lfr': '픩',
  'mfr': '픪',
  'nfr': '픫',
  'ofr': '픬',
  'pfr': '픭',
  'qfr': '픮',
  'rfr': '픯',
  'sfr': '픰',
  'tfr': '픱',
  'ufr': '픲',
  'vfr': '픳',
  'wfr': '픴',
  'xfr': '픵',
  'yfr': '픶',
  'zfr': '픷',
  'Aopf': '픸',
  'Bopf': '픹',
  'Dopf': '픻',
  'Eopf': '피',
  'Fopf': '픽',
  'Gopf': '픾',
  'Iopf': '핀',
  'Jopf': '핁',
  'Kopf': '핂',
  'Lopf': '핃',
  'Mopf': '필',
  'Oopf': '핆',
  'Sopf': '핊',
  'Topf': '핋',
  'Uopf': '핌',
  'Vopf': '핍',
  'Wopf': '핎',
  'Xopf': '핏',
  'Yopf': '핐',
  'aopf': '핒',
  'bopf': '핓',
  'copf': '핔',
  'dopf': '핕',
  'eopf': '핖',
  'fopf': '핗',
  'gopf': '하',
  'hopf': '학',
  'iopf': '핚',
  'jopf': '핛',
  'kopf': '한',
  'lopf': '핝',
  'mopf': '핞',
  'nopf': '핟',
  'oopf': '할',
  'popf': '핡',
  'qopf': '핢',
  'ropf': '핣',
  'sopf': '핤',
  'topf': '핥',
  'uopf': '핦',
  'vopf': '핧',
  'wopf': '함',
  'xopf': '합',
  'yopf': '핪',
  'zopf': '핫'
};

var specialCharEntities = {
  '&': '&amp;',
  '"': '&quot;',
  '<': '&lt;',
  '>': '&gt;',
  '\xA0': '&nbsp;'
};

var entityRegExp = /&(?:#([0-9]+)|#x([0-9a-f]+)|([a-z0-9]+));/gi;
var attributeModeSpecialCharRegExp = /["&<>\xA0]/g;
var nonAttributeModeSpecialCharRegExp = /[&<>\xA0]/g;

exports.HTMLDecode = function decode(s) {
  if (!s) return '';
  return s.replace(entityRegExp, function ($0, decimalStr, hexStr, entityName) {
    if (decimalStr) {
      return String.fromCharCode(parseInt(decimalStr, 10));
    } else if (hexStr) {
      return String.fromCharCode(parseInt(hexStr, 16));
    } else {
      // Fall back to the original string if we don't know the entity, as per browser behavior:
      return charByEntityName[entityName] || $0;
    }
  });
};

function specialCharToEntity(s) {
  var entity = specialCharEntities[s];
  return entity ? entity : s;
}

exports.HTMLEncode = function encode(s, attributeMode) {
  if (!s) return '';
  if (!s.replace) return s;
  if(attributeMode) {
	  return s.replace(attributeModeSpecialCharRegExp, specialCharToEntity);
  } else {
	  return s.replace(nonAttributeModeSpecialCharRegExp, specialCharToEntity);
  }
};

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/browser/domtohtml.js", function (require, module, exports, __dirname, __filename) {
//Make configurable from docType??
//Set in option
var isXHTML = false;

//List from node-htmlparser
var singleTags = {
  area: 1,
  base: 1,
  basefont: 1,
  br: 1,
  col: 1,
  frame: 1,
  hr: 1,
  img: 1,
  input: 1,
  isindex: 1,
  link: 1,
  meta: 1,
  param: 1,
  embed: 1
};

var expr = {
  upperCaseChars: /([A-Z])/g,
  breakBetweenTags: /(<(\/?\w+).*?>)(?=<(?!\/\2))/gi,
  singleTag: (function() {
    var tags = [];
    for (var i in singleTags) {
      tags.push(i);
    }
    return new RegExp('<' + tags.join('|<'), 'i');
  })()
};

var uncanon = function(str, letter) {
  return '-' + letter.toLowerCase();
};

var HTMLEncode = require('./htmlencoding').HTMLEncode;

exports.stringifyElement = function stringifyElement(element) {
  var tagName = element.tagName.toLowerCase(),
      ret = {
        start: "<" + tagName,
        end:''
      },
      attributes = [],
      i,
      attribute = null;

  //sys.puts('Checking Attributes: ' + element._attributes.length);
  //sys.puts(sys.inspect(element));
  if (element.attributes.length) {
    ret.start += " ";
    for (i = 0; i<element.attributes.length; i++) {
      attribute = element.attributes.item(i);
      attributes.push(attribute.name + '="' +
                      HTMLEncode(attribute.nodeValue, true) + '"');
    }
  }
  ret.start += attributes.join(" ");

  if (singleTags[tagName]) {
    if (isXHTML) {
        ret.start += "/";
    }
    ret.start += ">";
    ret.end = '';
  } else {
    ret.start += ">";
    ret.end = "</" + tagName + ">";
  }

  return ret;
};

var rawTextElements = /SCRIPT|STYLE/i;

function stringifyDoctype (doctype) {
  if (doctype.ownerDocument && doctype.ownerDocument._fullDT) {
    return doctype.ownerDocument._fullDT;
  }

  var dt = '<!DOCTYPE ' + doctype.name;
  if (doctype.publicId) {
    // Public ID may never contain double quotes, so this is always safe.
    dt += ' PUBLIC "' + doctype.publicId + '" ';
  }
  if (!doctype.publicId && doctype.systemId) {
    dt += ' SYSTEM ';
  }
  if (doctype.systemId) {
    // System ID may contain double quotes OR single quotes, not never both.
    if (doctype.systemId.indexOf('"') > -1) {
      dt += "'" + doctype.systemId + "'";
    } else {
      dt += '"' + doctype.systemId + '"';
    }
  }
  dt += '>';
  return dt;
}

exports.makeHtmlGenerator = function makeHtmlGenerator(indentUnit, eol) {
  indentUnit = indentUnit || "";
  eol = eol || "";

  return function generateHtmlRecursive(node, rawText, curIndent) {
    var ret = "", parent, current, i;
    curIndent = curIndent || "";
    if (node) {
      if (node.nodeType &&
          node.nodeType === node.ENTITY_REFERENCE_NODE) {
        node = node._entity;
      }

      var childNodesRawText = rawText || rawTextElements.test(node.nodeName);

      switch (node.nodeType) {
        case node.ELEMENT_NODE:
          current = exports.stringifyElement(node);
          if (childNodesRawText) {
            ret += curIndent + current.start;
          } else {
            ret += curIndent + current.start;
          }
          if (node._childNodes.length > 0) {
            if (node._childNodes[0].nodeType !== node.TEXT_NODE) {
              ret += eol;
            }
            for (i=0; i<node._childNodes.length; i++) {
              ret += generateHtmlRecursive(node._childNodes[i], childNodesRawText, curIndent + indentUnit);
            }
            if (node._childNodes[node._childNodes.length - 1].nodeType !== node.TEXT_NODE) {
              ret += curIndent;
            }
            ret += current.end + eol;
          } else {
            ret += ((rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '') + current.end + eol;
          }
          break;
        case node.TEXT_NODE:
          // Skip pure whitespace nodes if we're indenting
          if (!indentUnit || !/^[\s\n]*$/.test(node.nodeValue)) {
            ret += (rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '';
          }
          break;
        case node.COMMENT_NODE:
          ret += curIndent + '<!--' + node.nodeValue + '-->' + eol;
          break;
        case node.DOCUMENT_NODE:
          for (i=0; i<node._childNodes.length; i++) {
            ret += generateHtmlRecursive(node._childNodes[i], childNodesRawText, curIndent);
          }
          break;
        case node.DOCUMENT_TYPE_NODE:
          ret += stringifyDoctype(node);
        break;
      }
    }
    return ret;
  };
};

exports.domToHtml = function(dom, noformat, raw) {
  var htmlGenerator = exports.makeHtmlGenerator(noformat ? "" : "  ",
                                                noformat ? "" : "\n");
  if (dom.toArray) {
    // node list
    dom = dom.toArray();
  }
  if (Array.isArray(dom)) {
    var ret = "";
    for (var i=0,len=dom.length; i<len; i++) {
      ret += htmlGenerator(dom[i], raw);
    }
    return ret;
  } else {
    // single node
    return htmlGenerator(dom, raw);
  }
};

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/contextify/package.json", function (require, module, exports, __dirname, __filename) {
module.exports = {"main":"./lib/contextify"}
});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/contextify/lib/contextify.js", function (require, module, exports, __dirname, __filename) {
var ContextifyContext = require('bindings')('contextify').ContextifyContext;

module.exports = function Contextify (sandbox) {
    if (typeof sandbox != 'object') {
        sandbox = {};
    }
    var ctx = new ContextifyContext(sandbox);

    sandbox.run = function () {
        return ctx.run.apply(ctx, arguments);
    };

    sandbox.getGlobal = function () {
        return ctx.getGlobal();
    }

    sandbox.dispose = function () {
        sandbox.run = function () {
            throw new Error("Called run() after dispose().");
        };
        sandbox.getGlobal = function () {
            throw new Error("Called getGlobal() after dispose().");
        };
        sandbox.dispose = function () {
            throw new Error("Called dispose() after dispose().");
        };
        ctx = null;
    }
    return sandbox;
}

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/htmlparser/package.json", function (require, module, exports, __dirname, __filename) {
module.exports = {"main":"./lib/htmlparser"}
});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/htmlparser/lib/htmlparser.js", function (require, module, exports, __dirname, __filename) {
/***********************************************
Copyright 2010, 2011, Chris Winberry <chris@winberry.net>. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
***********************************************/
/* v1.7.4 */

(function () {

function runningInNode () {
	return(
		(typeof require) == "function"
		&&
		(typeof exports) == "object"
		&&
		(typeof module) == "object"
		&&
		(typeof __filename) == "string"
		&&
		(typeof __dirname) == "string"
		);
}

if (!runningInNode()) {
	if (!this.Tautologistics)
		this.Tautologistics = {};
	else if (this.Tautologistics.NodeHtmlParser)
		return; //NodeHtmlParser already defined!
	this.Tautologistics.NodeHtmlParser = {};
	exports = this.Tautologistics.NodeHtmlParser;
}

//Types of elements found in the DOM
var ElementType = {
	  Text: "text" //Plain text
	, Directive: "directive" //Special tag <!...>
	, Comment: "comment" //Special tag <!--...-->
	, Script: "script" //Special tag <script>...</script>
	, Style: "style" //Special tag <style>...</style>
	, Tag: "tag" //Any tag that isn't special
}

function Parser (handler, options) {
	this._options = options ? options : { };
	if (this._options.includeLocation == undefined) {
		this._options.includeLocation = false; //Do not track element position in document by default
	}

	this.validateHandler(handler);
	this._handler = handler;
	this.reset();
}

	//**"Static"**//
	//Regular expressions used for cleaning up and parsing (stateless)
	Parser._reTrim = /(^\s+|\s+$)/g; //Trim leading/trailing whitespace
	Parser._reTrimComment = /(^\!--|--$)/g; //Remove comment tag markup from comment contents
	Parser._reWhitespace = /\s/g; //Used to find any whitespace to split on
	Parser._reTagName = /^\s*(\/?)\s*([^\s\/]+)/; //Used to find the tag name for an element

	//Regular expressions used for parsing (stateful)
	Parser._reAttrib = //Find attributes in a tag
		/([^=<>\"\'\s]+)\s*=\s*"([^"]*)"|([^=<>\"\'\s]+)\s*=\s*'([^']*)'|([^=<>\"\'\s]+)\s*=\s*([^'"\s]+)|([^=<>\"\'\s\/]+)/g;
	Parser._reTags = /[\<\>]/g; //Find tag markers

	//**Public**//
	//Methods//
	//Parses a complete HTML and pushes it to the handler
	Parser.prototype.parseComplete = function Parser$parseComplete (data) {
		this.reset();
		this.parseChunk(data);
		this.done();
	}

	//Parses a piece of an HTML document
	Parser.prototype.parseChunk = function Parser$parseChunk (data) {
		if (this._done)
			this.handleError(new Error("Attempted to parse chunk after parsing already done"));
		this._buffer += data; //FIXME: this can be a bottleneck
		this.parseTags();
	}

	//Tells the parser that the HTML being parsed is complete
	Parser.prototype.done = function Parser$done () {
		if (this._done)
			return;
		this._done = true;
	
		//Push any unparsed text into a final element in the element list
		if (this._buffer.length) {
			var rawData = this._buffer;
			this._buffer = "";
			var element = {
				  raw: rawData
				, data: (this._parseState == ElementType.Text) ? rawData : rawData.replace(Parser._reTrim, "")
				, type: this._parseState
				};
			if (this._parseState == ElementType.Tag || this._parseState == ElementType.Script || this._parseState == ElementType.Style)
				element.name = this.parseTagName(element.data);
			this.parseAttribs(element);
			this._elements.push(element);
		}
	
		this.writeHandler();
		this._handler.done();
	}

	//Resets the parser to a blank state, ready to parse a new HTML document
	Parser.prototype.reset = function Parser$reset () {
		this._buffer = "";
		this._done = false;
		this._elements = [];
		this._elementsCurrent = 0;
		this._current = 0;
		this._next = 0;
		this._location = {
			  row: 0
			, col: 0
			, charOffset: 0
			, inBuffer: 0
		};
		this._parseState = ElementType.Text;
		this._prevTagSep = '';
		this._tagStack = [];
		this._handler.reset();
	}
	
	//**Private**//
	//Properties//
	Parser.prototype._options = null; //Parser options for how to behave
	Parser.prototype._handler = null; //Handler for parsed elements
	Parser.prototype._buffer = null; //Buffer of unparsed data
	Parser.prototype._done = false; //Flag indicating whether parsing is done
	Parser.prototype._elements =  null; //Array of parsed elements
	Parser.prototype._elementsCurrent = 0; //Pointer to last element in _elements that has been processed
	Parser.prototype._current = 0; //Position in data that has already been parsed
	Parser.prototype._next = 0; //Position in data of the next tag marker (<>)
	Parser.prototype._location = null; //Position tracking for elements in a stream
	Parser.prototype._parseState = ElementType.Text; //Current type of element being parsed
	Parser.prototype._prevTagSep = ''; //Previous tag marker found
	//Stack of element types previously encountered; keeps track of when
	//parsing occurs inside a script/comment/style tag
	Parser.prototype._tagStack = null;

	//Methods//
	//Takes an array of elements and parses any found attributes
	Parser.prototype.parseTagAttribs = function Parser$parseTagAttribs (elements) {
		var idxEnd = elements.length;
		var idx = 0;
	
		while (idx < idxEnd) {
			var element = elements[idx++];
			if (element.type == ElementType.Tag || element.type == ElementType.Script || element.type == ElementType.style)
				this.parseAttribs(element);
		}
	
		return(elements);
	}

	//Takes an element and adds an "attribs" property for any element attributes found 
	Parser.prototype.parseAttribs = function Parser$parseAttribs (element) {
		//Only parse attributes for tags
		if (element.type != ElementType.Script && element.type != ElementType.Style && element.type != ElementType.Tag)
			return;
	
		var tagName = element.data.split(Parser._reWhitespace, 1)[0];
		var attribRaw = element.data.substring(tagName.length);
		if (attribRaw.length < 1)
			return;
	
		var match;
		Parser._reAttrib.lastIndex = 0;
		while (match = Parser._reAttrib.exec(attribRaw)) {
			if (element.attribs == undefined)
				element.attribs = {};
	
			if (typeof match[1] == "string" && match[1].length) {
				element.attribs[match[1]] = match[2];
			} else if (typeof match[3] == "string" && match[3].length) {
				element.attribs[match[3].toString()] = match[4].toString();
			} else if (typeof match[5] == "string" && match[5].length) {
				element.attribs[match[5]] = match[6];
			} else if (typeof match[7] == "string" && match[7].length) {
				element.attribs[match[7]] = match[7];
			}
		}
	}

	//Extracts the base tag name from the data value of an element
	Parser.prototype.parseTagName = function Parser$parseTagName (data) {
		if (data == null || data == "")
			return("");
		var match = Parser._reTagName.exec(data);
		if (!match)
			return("");
		return((match[1] ? "/" : "") + match[2]);
	}

	//Parses through HTML text and returns an array of found elements
	//I admit, this function is rather large but splitting up had an noticeable impact on speed
	Parser.prototype.parseTags = function Parser$parseTags () {
		var bufferEnd = this._buffer.length - 1;
		while (Parser._reTags.test(this._buffer)) {
			this._next = Parser._reTags.lastIndex - 1;
			var tagSep = this._buffer.charAt(this._next); //The currently found tag marker
			var rawData = this._buffer.substring(this._current, this._next); //The next chunk of data to parse
	
			//A new element to eventually be appended to the element list
			var element = {
				  raw: rawData
				, data: (this._parseState == ElementType.Text) ? rawData : rawData.replace(Parser._reTrim, "")
				, type: this._parseState
			};
	
			var elementName = this.parseTagName(element.data);
	
			//This section inspects the current tag stack and modifies the current
			//element if we're actually parsing a special area (script/comment/style tag)
			if (this._tagStack.length) { //We're parsing inside a script/comment/style tag
				if (this._tagStack[this._tagStack.length - 1] == ElementType.Script) { //We're currently in a script tag
					if (elementName == "/script") //Actually, we're no longer in a script tag, so pop it off the stack
						this._tagStack.pop();
					else { //Not a closing script tag
						if (element.raw.indexOf("!--") != 0) { //Make sure we're not in a comment
							//All data from here to script close is now a text element
							element.type = ElementType.Text;
							//If the previous element is text, append the current text to it
							if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Text) {
								var prevElement = this._elements[this._elements.length - 1];
								prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep + element.raw;
								element.raw = element.data = ""; //This causes the current element to not be added to the element list
							}
						}
					}
				}
				else if (this._tagStack[this._tagStack.length - 1] == ElementType.Style) { //We're currently in a style tag
					if (elementName == "/style") //Actually, we're no longer in a style tag, so pop it off the stack
						this._tagStack.pop();
					else {
						if (element.raw.indexOf("!--") != 0) { //Make sure we're not in a comment
							//All data from here to style close is now a text element
							element.type = ElementType.Text;
							//If the previous element is text, append the current text to it
							if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Text) {
								var prevElement = this._elements[this._elements.length - 1];
								if (element.raw != "") {
									prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep + element.raw;
									element.raw = element.data = ""; //This causes the current element to not be added to the element list
								} else { //Element is empty, so just append the last tag marker found
									prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep;
								}
							} else { //The previous element was not text
								if (element.raw != "") {
									element.raw = element.data = element.raw;
								}
							}
						}
					}
				}
				else if (this._tagStack[this._tagStack.length - 1] == ElementType.Comment) { //We're currently in a comment tag
					var rawLen = element.raw.length;
					if (element.raw.charAt(rawLen - 2) == "-" && element.raw.charAt(rawLen - 1) == "-" && tagSep == ">") {
						//Actually, we're no longer in a style tag, so pop it off the stack
						this._tagStack.pop();
						//If the previous element is a comment, append the current text to it
						if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Comment) {
							var prevElement = this._elements[this._elements.length - 1];
							prevElement.raw = prevElement.data = (prevElement.raw + element.raw).replace(Parser._reTrimComment, "");
							element.raw = element.data = ""; //This causes the current element to not be added to the element list
							element.type = ElementType.Text;
						}
						else //Previous element not a comment
							element.type = ElementType.Comment; //Change the current element's type to a comment
					}
					else { //Still in a comment tag
						element.type = ElementType.Comment;
						//If the previous element is a comment, append the current text to it
						if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Comment) {
							var prevElement = this._elements[this._elements.length - 1];
							prevElement.raw = prevElement.data = prevElement.raw + element.raw + tagSep;
							element.raw = element.data = ""; //This causes the current element to not be added to the element list
							element.type = ElementType.Text;
						}
						else
							element.raw = element.data = element.raw + tagSep;
					}
				}
			}
	
			//Processing of non-special tags
			if (element.type == ElementType.Tag) {
				element.name = elementName;
				
				if (element.raw.indexOf("!--") == 0) { //This tag is really comment
					element.type = ElementType.Comment;
					delete element["name"];
					var rawLen = element.raw.length;
					//Check if the comment is terminated in the current element
					if (element.raw.charAt(rawLen - 1) == "-" && element.raw.charAt(rawLen - 2) == "-" && tagSep == ">")
						element.raw = element.data = element.raw.replace(Parser._reTrimComment, "");
					else { //It's not so push the comment onto the tag stack
						element.raw += tagSep;
						this._tagStack.push(ElementType.Comment);
					}
				}
				else if (element.raw.indexOf("!") == 0 || element.raw.indexOf("?") == 0) {
					element.type = ElementType.Directive;
					//TODO: what about CDATA?
				}
				else if (element.name == "script") {
					element.type = ElementType.Script;
					//Special tag, push onto the tag stack if not terminated
					if (element.data.charAt(element.data.length - 1) != "/")
						this._tagStack.push(ElementType.Script);
				}
				else if (element.name == "/script")
					element.type = ElementType.Script;
				else if (element.name == "style") {
					element.type = ElementType.Style;
					//Special tag, push onto the tag stack if not terminated
					if (element.data.charAt(element.data.length - 1) != "/")
						this._tagStack.push(ElementType.Style);
				}
				else if (element.name == "/style")
					element.type = ElementType.Style;
				if (element.name && element.name.charAt(0) == "/")
					element.data = element.name;
			}
	
			//Add all tags and non-empty text elements to the element list
			if (element.raw != "" || element.type != ElementType.Text) {
				if (this._options.includeLocation && !element.location) {
					element.location = this.getLocation(element.type == ElementType.Tag);
				}
				this.parseAttribs(element);
				this._elements.push(element);
				//If tag self-terminates, add an explicit, separate closing tag
				if (
					element.type != ElementType.Text
					&&
					element.type != ElementType.Comment
					&&
					element.type != ElementType.Directive
					&&
					element.data.charAt(element.data.length - 1) == "/"
					)
					this._elements.push({
						  raw: "/" + element.name
						, data: "/" + element.name
						, name: "/" + element.name
						, type: element.type
					});
			}
			this._parseState = (tagSep == "<") ? ElementType.Tag : ElementType.Text;
			this._current = this._next + 1;
			this._prevTagSep = tagSep;
		}

		if (this._options.includeLocation) {
			this.getLocation();
			this._location.row += this._location.inBuffer;
			this._location.inBuffer = 0;
			this._location.charOffset = 0;
		}
		this._buffer = (this._current <= bufferEnd) ? this._buffer.substring(this._current) : "";
		this._current = 0;
	
		this.writeHandler();
	}

	Parser.prototype.getLocation = function Parser$getLocation (startTag) {
		var c,
			l = this._location,
			end = this._current - (startTag ? 1 : 0),
			chunk = startTag && l.charOffset == 0 && this._current == 0;
		
		for (; l.charOffset < end; l.charOffset++) {
			c = this._buffer.charAt(l.charOffset);
			if (c == '\n') {
				l.inBuffer++;
				l.col = 0;
			} else if (c != '\r') {
				l.col++;
			}
		}
		return {
			  line: l.row + l.inBuffer + 1
			, col: l.col + (chunk ? 0: 1)
		};
	}

	//Checks the handler to make it is an object with the right "interface"
	Parser.prototype.validateHandler = function Parser$validateHandler (handler) {
		if ((typeof handler) != "object")
			throw new Error("Handler is not an object");
		if ((typeof handler.reset) != "function")
			throw new Error("Handler method 'reset' is invalid");
		if ((typeof handler.done) != "function")
			throw new Error("Handler method 'done' is invalid");
		if ((typeof handler.writeTag) != "function")
			throw new Error("Handler method 'writeTag' is invalid");
		if ((typeof handler.writeText) != "function")
			throw new Error("Handler method 'writeText' is invalid");
		if ((typeof handler.writeComment) != "function")
			throw new Error("Handler method 'writeComment' is invalid");
		if ((typeof handler.writeDirective) != "function")
			throw new Error("Handler method 'writeDirective' is invalid");
	}

	//Writes parsed elements out to the handler
	Parser.prototype.writeHandler = function Parser$writeHandler (forceFlush) {
		forceFlush = !!forceFlush;
		if (this._tagStack.length && !forceFlush)
			return;
		while (this._elements.length) {
			var element = this._elements.shift();
			switch (element.type) {
				case ElementType.Comment:
					this._handler.writeComment(element);
					break;
				case ElementType.Directive:
					this._handler.writeDirective(element);
					break;
				case ElementType.Text:
					this._handler.writeText(element);
					break;
				default:
					this._handler.writeTag(element);
					break;
			}
		}
	}

	Parser.prototype.handleError = function Parser$handleError (error) {
		if ((typeof this._handler.error) == "function")
			this._handler.error(error);
		else
			throw error;
	}

//TODO: make this a trully streamable handler
function RssHandler (callback) {
	RssHandler.super_.call(this, callback, { ignoreWhitespace: true, verbose: false, enforceEmptyTags: false });
}
inherits(RssHandler, DefaultHandler);

	RssHandler.prototype.done = function RssHandler$done () {
		var feed = { };
		var feedRoot;

		var found = DomUtils.getElementsByTagName(function (value) { return(value == "rss" || value == "feed"); }, this.dom, false);
		if (found.length) {
			feedRoot = found[0];
		}
		if (feedRoot) {
			if (feedRoot.name == "rss") {
				feed.type = "rss";
				feedRoot = feedRoot.children[0]; //<channel/>
				feed.id = "";
				try {
					feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.description = DomUtils.getElementsByTagName("description", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.updated = new Date(DomUtils.getElementsByTagName("lastBuildDate", feedRoot.children, false)[0].children[0].data);
				} catch (ex) { }
				try {
					feed.author = DomUtils.getElementsByTagName("managingEditor", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				feed.items = [];
				DomUtils.getElementsByTagName("item", feedRoot.children).forEach(function (item, index, list) {
					var entry = {};
					try {
						entry.id = DomUtils.getElementsByTagName("guid", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.title = DomUtils.getElementsByTagName("title", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.link = DomUtils.getElementsByTagName("link", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.description = DomUtils.getElementsByTagName("description", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.pubDate = new Date(DomUtils.getElementsByTagName("pubDate", item.children, false)[0].children[0].data);
					} catch (ex) { }
					feed.items.push(entry);
				});
			} else {
				feed.type = "atom";
				try {
					feed.id = DomUtils.getElementsByTagName("id", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].attribs.href;
				} catch (ex) { }
				try {
					feed.description = DomUtils.getElementsByTagName("subtitle", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.updated = new Date(DomUtils.getElementsByTagName("updated", feedRoot.children, false)[0].children[0].data);
				} catch (ex) { }
				try {
					feed.author = DomUtils.getElementsByTagName("email", feedRoot.children, true)[0].children[0].data;
				} catch (ex) { }
				feed.items = [];
				DomUtils.getElementsByTagName("entry", feedRoot.children).forEach(function (item, index, list) {
					var entry = {};
					try {
						entry.id = DomUtils.getElementsByTagName("id", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.title = DomUtils.getElementsByTagName("title", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.link = DomUtils.getElementsByTagName("link", item.children, false)[0].attribs.href;
					} catch (ex) { }
					try {
						entry.description = DomUtils.getElementsByTagName("summary", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.pubDate = new Date(DomUtils.getElementsByTagName("updated", item.children, false)[0].children[0].data);
					} catch (ex) { }
					feed.items.push(entry);
				});
			}

			this.dom = feed;
		}
		RssHandler.super_.prototype.done.call(this);
	}

///////////////////////////////////////////////////

function DefaultHandler (callback, options) {
	this.reset();
	this._options = options ? options : { };
	if (this._options.ignoreWhitespace == undefined)
		this._options.ignoreWhitespace = false; //Keep whitespace-only text nodes
	if (this._options.verbose == undefined)
		this._options.verbose = true; //Keep data property for tags and raw property for all
	if (this._options.enforceEmptyTags == undefined)
		this._options.enforceEmptyTags = true; //Don't allow children for HTML tags defined as empty in spec
	if ((typeof callback) == "function")
		this._callback = callback;
}

	//**"Static"**//
	//HTML Tags that shouldn't contain child nodes
	DefaultHandler._emptyTags = {
		  area: 1
		, base: 1
		, basefont: 1
		, br: 1
		, col: 1
		, frame: 1
		, hr: 1
		, img: 1
		, input: 1
		, isindex: 1
		, link: 1
		, meta: 1
		, param: 1
		, embed: 1
	}
	//Regex to detect whitespace only text nodes
	DefaultHandler.reWhitespace = /^\s*$/;

	//**Public**//
	//Properties//
	DefaultHandler.prototype.dom = null; //The hierarchical object containing the parsed HTML
	//Methods//
	//Resets the handler back to starting state
	DefaultHandler.prototype.reset = function DefaultHandler$reset() {
		this.dom = [];
		this._done = false;
		this._tagStack = [];
		this._tagStack.last = function DefaultHandler$_tagStack$last () {
			return(this.length ? this[this.length - 1] : null);
		}
	}
	//Signals the handler that parsing is done
	DefaultHandler.prototype.done = function DefaultHandler$done () {
		this._done = true;
		this.handleCallback(null);
	}
	DefaultHandler.prototype.writeTag = function DefaultHandler$writeTag (element) {
		this.handleElement(element);
	} 
	DefaultHandler.prototype.writeText = function DefaultHandler$writeText (element) {
		if (this._options.ignoreWhitespace)
			if (DefaultHandler.reWhitespace.test(element.data))
				return;
		this.handleElement(element);
	} 
	DefaultHandler.prototype.writeComment = function DefaultHandler$writeComment (element) {
		this.handleElement(element);
	} 
	DefaultHandler.prototype.writeDirective = function DefaultHandler$writeDirective (element) {
		this.handleElement(element);
	}
	DefaultHandler.prototype.error = function DefaultHandler$error (error) {
		this.handleCallback(error);
	}

	//**Private**//
	//Properties//
	DefaultHandler.prototype._options = null; //Handler options for how to behave
	DefaultHandler.prototype._callback = null; //Callback to respond to when parsing done
	DefaultHandler.prototype._done = false; //Flag indicating whether handler has been notified of parsing completed
	DefaultHandler.prototype._tagStack = null; //List of parents to the currently element being processed
	//Methods//
	DefaultHandler.prototype.handleCallback = function DefaultHandler$handleCallback (error) {
			if ((typeof this._callback) != "function")
				if (error)
					throw error;
				else
					return;
			this._callback(error, this.dom);
	}
	
	DefaultHandler.prototype.isEmptyTag = function(element) {
		var name = element.name.toLowerCase();
		if (name.charAt(0) == '/') {
			name = name.substring(1);
		}
		return this._options.enforceEmptyTags && !!DefaultHandler._emptyTags[name];
	};
	
	DefaultHandler.prototype.handleElement = function DefaultHandler$handleElement (element) {
		if (this._done)
			this.handleCallback(new Error("Writing to the handler after done() called is not allowed without a reset()"));
		if (!this._options.verbose) {
//			element.raw = null; //FIXME: Not clean
			//FIXME: Serious performance problem using delete
			delete element.raw;
			if (element.type == "tag" || element.type == "script" || element.type == "style")
				delete element.data;
		}
		if (!this._tagStack.last()) { //There are no parent elements
			//If the element can be a container, add it to the tag stack and the top level list
			if (element.type != ElementType.Text && element.type != ElementType.Comment && element.type != ElementType.Directive) {
				if (element.name.charAt(0) != "/") { //Ignore closing tags that obviously don't have an opening tag
					this.dom.push(element);
					if (!this.isEmptyTag(element)) { //Don't add tags to the tag stack that can't have children
						this._tagStack.push(element);
					}
				}
			}
			else //Otherwise just add to the top level list
				this.dom.push(element);
		}
		else { //There are parent elements
			//If the element can be a container, add it as a child of the element
			//on top of the tag stack and then add it to the tag stack
			if (element.type != ElementType.Text && element.type != ElementType.Comment && element.type != ElementType.Directive) {
				if (element.name.charAt(0) == "/") {
					//This is a closing tag, scan the tagStack to find the matching opening tag
					//and pop the stack up to the opening tag's parent
					var baseName = element.name.substring(1);
					if (!this.isEmptyTag(element)) {
						var pos = this._tagStack.length - 1;
						while (pos > -1 && this._tagStack[pos--].name != baseName) { }
						if (pos > -1 || this._tagStack[0].name == baseName)
							while (pos < this._tagStack.length - 1)
								this._tagStack.pop();
					}
				}
				else { //This is not a closing tag
					if (!this._tagStack.last().children)
						this._tagStack.last().children = [];
					this._tagStack.last().children.push(element);
					if (!this.isEmptyTag(element)) //Don't add tags to the tag stack that can't have children
						this._tagStack.push(element);
				}
			}
			else { //This is not a container element
				if (!this._tagStack.last().children)
					this._tagStack.last().children = [];
				this._tagStack.last().children.push(element);
			}
		}
	}

	var DomUtils = {
		  testElement: function DomUtils$testElement (options, element) {
			if (!element) {
				return false;
			}
	
			for (var key in options) {
				if (key == "tag_name") {
					if (element.type != "tag" && element.type != "script" && element.type != "style") {
						return false;
					}
					if (!options["tag_name"](element.name)) {
						return false;
					}
				} else if (key == "tag_type") {
					if (!options["tag_type"](element.type)) {
						return false;
					}
				} else if (key == "tag_contains") {
					if (element.type != "text" && element.type != "comment" && element.type != "directive") {
						return false;
					}
					if (!options["tag_contains"](element.data)) {
						return false;
					}
				} else {
					if (!element.attribs || !options[key](element.attribs[key])) {
						return false;
					}
				}
			}
		
			return true;
		}
	
		, getElements: function DomUtils$getElements (options, currentElement, recurse, limit) {
			recurse = (recurse === undefined || recurse === null) || !!recurse;
			limit = isNaN(parseInt(limit)) ? -1 : parseInt(limit);

			if (!currentElement) {
				return([]);
			}
	
			var found = [];
			var elementList;

			function getTest (checkVal) {
				return(function (value) { return(value == checkVal); });
			}
			for (var key in options) {
				if ((typeof options[key]) != "function") {
					options[key] = getTest(options[key]);
				}
			}
	
			if (DomUtils.testElement(options, currentElement)) {
				found.push(currentElement);
			}

			if (limit >= 0 && found.length >= limit) {
				return(found);
			}

			if (recurse && currentElement.children) {
				elementList = currentElement.children;
			} else if (currentElement instanceof Array) {
				elementList = currentElement;
			} else {
				return(found);
			}
	
			for (var i = 0; i < elementList.length; i++) {
				found = found.concat(DomUtils.getElements(options, elementList[i], recurse, limit));
				if (limit >= 0 && found.length >= limit) {
					break;
				}
			}
	
			return(found);
		}
		
		, getElementById: function DomUtils$getElementById (id, currentElement, recurse) {
			var result = DomUtils.getElements({ id: id }, currentElement, recurse, 1);
			return(result.length ? result[0] : null);
		}
		
		, getElementsByTagName: function DomUtils$getElementsByTagName (name, currentElement, recurse, limit) {
			return(DomUtils.getElements({ tag_name: name }, currentElement, recurse, limit));
		}
		
		, getElementsByTagType: function DomUtils$getElementsByTagType (type, currentElement, recurse, limit) {
			return(DomUtils.getElements({ tag_type: type }, currentElement, recurse, limit));
		}
	}

	function inherits (ctor, superCtor) {
		var tempCtor = function(){};
		tempCtor.prototype = superCtor.prototype;
		ctor.super_ = superCtor;
		ctor.prototype = new tempCtor();
		ctor.prototype.constructor = ctor;
	}

exports.Parser = Parser;

exports.DefaultHandler = DefaultHandler;

exports.RssHandler = RssHandler;

exports.ElementType = ElementType;

exports.DomUtils = DomUtils;

})();

});

require.define("/node_modules/testling/node_modules/jsdom/node_modules/htmlparser/lib/node-htmlparser.js", function (require, module, exports, __dirname, __filename) {
var htmlparser = require("./htmlparser");
exports.Parser = htmlparser.Parser;
exports.DefaultHandler = htmlparser.DefaultHandler;
exports.RssHandler = htmlparser.RssHandler;
exports.ElementType = htmlparser.ElementType;
exports.DomUtils = htmlparser.DomUtils;

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/selectors/index.js", function (require, module, exports, __dirname, __filename) {
var Sizzle = require("./sizzle").Sizzle;
exports.applyQuerySelectorPrototype = function(dom) {
  dom.Document.prototype.querySelector = function(selector) {
    return Sizzle(selector, this)[0];
  };

  dom.Document.prototype.querySelectorAll = function(selector) {
    var self = this;
    return new dom.NodeList(self, function() {
      return Sizzle(selector, self);
    });
  };

  dom.Element.prototype.querySelector = function(selector) {
    return Sizzle(selector, this)[0];
  };

  dom.Element.prototype.querySelectorAll = function(selector) {
    var self = this;
    if( !this.parentNode ){
      self = this.ownerDocument.createElement("div");
      self.appendChild(this);
    }
    return new dom.NodeList(self.ownerDocument, function() {
      return Sizzle(selector, self.parentNode || self);
    });
  };
};

});

require.define("/node_modules/testling/node_modules/jsdom/lib/jsdom/selectors/sizzle.js", function (require, module, exports, __dirname, __filename) {
/*!
 * Sizzle CSS Selector Engine - v1.0
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var match,
			type = Expr.order[i];

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace(/\\/g, "");
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = context.getElementsByTagName( "*" );
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var found, item,
					filter = Expr.filter[ type ],
					left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !/\W/.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !/\W/.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !/\W/.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			return context.getElementsByTagName( match[1] );
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace(/\\/g, "") + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace(/\\/g, "");
		},

		TAG: function( match, curLoop ) {
			return match[1].toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1].replace(/\\/g, "");

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},

	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},

		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			elem.parentNode.selectedIndex;

			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			return "text" === elem.type;
		},
		radio: function( elem ) {
			return "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return "checkbox" === elem.type;
		},

		file: function( elem ) {
			return "file" === elem.type;
		},
		password: function( elem ) {
			return "password" === elem.type;
		},

		submit: function( elem ) {
			return "submit" === elem.type;
		},

		image: function( elem ) {
			return "image" === elem.type;
		},

		reset: function( elem ) {
			return "reset" === elem.type;
		},

		button: function( elem ) {
			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					if ( type === "first" ) {
						return true;
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					return true;

				case "nth":
					var first = match[2],
						last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					var doneName = match[0],
						parent = elem.parentNode;

					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent.sizcache = doneName;
					}

					var diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	var i = 0,
		ret = results || [];

	if ( toString.call(array) === "[object Array]" ) {
		Array.prototype.push.apply( ret, array );

	} else {
		if ( typeof array.length === "number" ) {
			for ( var l = array.length; i < l; i++ ) {
				ret.push( array[i] );
			}

		} else {
			for ( ; array[i]; i++ ) {
				ret.push( array[i] );
			}
		}
	}

	return ret;
};

var sortOrder, siblingCheck;

sortOrder = function( a, b ) {
	if ( a === b ) {
		hasDuplicate = true;
		return 0;
	}

	if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
		return a.compareDocumentPosition ? -1 : 1;
	}

	return a.compareDocumentPosition(b) & 4 ? -1 : 1;
};


// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

(function(){
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

Sizzle.contains = function( a, b ) {
	return !!(a.compareDocumentPosition(b) & 16);
};

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE

exports.Sizzle = Sizzle;

})();

});

require.define("/lib/CM1.js", function (require, module, exports, __dirname, __filename) {
// Carbon, energy, and other environmental impact calculations for your 
// JavaScript objects. Built for the browser and Node.js.
var ImpactEstimate = require('./impact-estimate'),
  ImpactEstimator = require('./impact-estimator');

var CM1 = function() {
  this.attributeMap = {};
};

// ## Usage
// For a quick, **one-off calculation**, you can use `CM1.impacts()`. Here's an example for a flight:
// 
//     var CM1 = require('cm1');
//     CM1.impacts('flight', {
//       origin_airport: 'IAD',
//       destination_airport: 'PDX',
//       airline: 'United',
//       trips: 2,
//       segments_per_trip: 1    // nonstop flight
//     },
//     function(err, impacts) {
//       if(err) return console.log('Argh, falied!', err);
// 
//       console.log('Carbon for my cross-country flight: ',
//                   impacts.carbon);
//       console.log('Methodology: ', impacts.methodology);
//     });
// 
CM1.impacts = function(type, properties, callback) {
  var model = CM1.model(type, properties);
  model.getImpacts(callback);
};

// Alternatively, `CM1.model()` can add impact calculation abilities to an
// **existing object** on which you can run calculations at a later time:
// 
//     var CM1 = require('cm1');
//     var model = CM1.model('flight', {
//       origin_airport: 'JFK',
//       destination_airport: 'Berlin',
//       airline: 'Luftansa'
//     });
// 
//     // later...
//     model.seat_class = 'Business';
// 
//     model.getImpacts(function(err, impacts) {
//       if(err) return console.log('Argh, falied!', err);
// 
//       console.log('Carbon for my international flight: ',
//                   impacts.carbon);
//       console.log('Methodology: ', impacts.methodology);
//     });
// 
CM1.model = function(type, properties) {
  var attributes = Object.keys(properties);

  var proto = function() {};
  CM1.extend(proto, {
    model: type,
    provides: attributes
  });

  var object = new proto();
  for(var i = 0; i < attributes.length; i++) {
    var attribute = attributes[i];
    object[attribute] = properties[attribute];
  }

  return object;
};

// You can also **extend any prototype** (class) to become and impact calculating machine. For example, let's
// say we have a class representing a rental car:
// 
// 
//     var RentalCar = function() {};
//     
//     var car = new RentalCar();
//     car.make = 'Honda';
//     car.model = 'Fit';
//     car.fuelEconomy = 36.7;
// 
// If you want to figure out how much CO2 it emits, use `CM1.extend()` to tell
// your prototype how to use CM1 to calculate impacts. The first argument is the
// prototype to extend, the second argument is a object that describes mappings
// between properties of your prototype instance to the characteristics sent to
// CM1. After executing `CM1.extend()`, A new function called `getImpacts()`
// will be added to your class. `CM1.extend()` must be run before instantiating
// the RentalCar.
// 
//     var RentalCar = function() {};
//     
//     CM1.extend(RentalCar, {
//       model: 'automobile',
//       provides: ['make', 'model', {
//         'fuel_efficiency': 'fuelEconomy'
//       }
//     });
// 
// This says "my RentalCar prototype will use the
// [Automobile emitter](http://carbon.brighterplanet.com/models/automobile) to calculate
// impacts. It uses the make property to provide make to the web service, model maps to
// model, and the fuelEconomy property maps to fuel_efficiency on CM1.
//
// Now you can calculate impacts:
// 
//     var car = new RentalCar();
//     car.make = 'Honda';
//     car.model = 'Fit';
//     car.fuelEconomy = 36.7;
// 
//     car.getImpacts(function(err, impacts) {
//       if(err) alert("Oops, something broke: " + err);
//  
//       alert("My emissions are: " + impacts.carbon);
//       alert("My fuel use is: " + impacts.fuelUse);
//     });
//
// There are a whole bunch of [other models](http://carbon.brighterplanet.com/models)
// available, including computer usage, rail trips, and flights.
// 
CM1.extend = function(klass, mapping) {
  klass.cm1 = new CM1();
  klass.cm1.define(mapping);
  klass.prototype.impactEstimator = new ImpactEstimator(klass.cm1);
  klass.prototype.getImpacts = function(callback) {
    return this.impactEstimator.getImpacts(this, callback);
  };
};

// ## Specifying an API Key
// 
// CM1 is free for non-commercial use and available for commercial use. In either 
// case, you need to sign up for a Brighter Planet API key if you haven't already.
// To do so, go to [keys.brighterplanet.com](http://keys.brighterplanet.com).
// 
// Once you have your key, you can specify it with:
// 
//     var CM1 = require('CM1');
//     process.env.CM1_KEY = 'ABC123';
//     
// Note: if using the stand-alone library, `process.env` won't be available in your
// browser until you `require('CM1')`.
// 
CM1.prototype.key = function() {
  if(process && process.env && process.env.CM1_KEY)
    return process.env.CM1_KEY;
  else
    return CM1.key;
};

// ## Connection Adapters: HTTP, Websockets, etc.
// CM1.js can use a **standard RESTful HTTP** adapter (default) or an **HTML5 Websockets** adapter.

// The **standard HTTP** adapter sends a separate HTTP request for each calculation 
// performed. This is ideal for when one or only a few calculations are made at 
// a given time.
CM1.useHttpAdapter = function() {
  CM1.setAdapter('http');
};

// The **Websockets** adapter is ideal for when many calculations need to be made at once.
// You will need to `npm install socket.io-client` to use this.
CM1.useWebsocketAdapter = function() {
  CM1.setAdapter('websocket');
};

// You can define process.env.CM1_ADAPTER to 'http' or 'websocket'. 
// Otherwise, CM1 defaults to the HTTP adapter
CM1.setAdapter = function(type) {
  process.env = process.env || {};
  type = type || process.env.CM1_ADAPTER || 'http';
  var adapter = type == 'http' ? 
    require('./adapters/http-adapter') :
    require('./adapters/websocket-adapter');
  CM1.adapter = new adapter();
};

// ## Etc.
// Apply a mapping to a CM1-enabled object.
CM1.prototype.define = function(mapping) {
  this.emitAs(mapping.model);
  var provisions = mapping.provide || mapping.provides;
  this.provide(provisions);
};

// Set the model (e.g. flight) used for calculation.
CM1.prototype.emitAs = function(model) {
  this.model = model;
};

// Define the properties of the CM1-enabled object that are sent as
// characteristics to CM1's models.
// The format of **attributes** can be:
//
// * `['foo', 'bar', 'baz']`
// * `['foo', 'bar', 'baz', { quux: 'quuxValue' }]`
// * `{ foo: 'fooProperty',  quux: 'quuxValue' }`
//
// When specifying an object parameter, the property name
// is the name of the CM1 characterstic, and the value is
// the name of the property or function on your object that
// holds the data to be sent.
CM1.prototype.provide = function(attributes) {
  for(var i in attributes) {
    if(attributes.hasOwnProperty(i)) {
      var value = attributes[i];
      if(typeof value == 'object') {
        this.provide(value);
      } else if(/^\d+$/.test(i)) {
        this.attributeMap[this.underscore(value)] = value;
      } else {
        this.attributeMap[this.underscore(i)] = value;
      }
    }
  }
};

CM1.prototype.underscore = function(string) {
  return string.replace(/([a-z])([A-Z])/g, function(str, first, second) {
    return first + '_' + second.toLowerCase();
  });
};

CM1.prototype.adapter = function() {
  if(!CM1.adapter) CM1.setAdapter();
  return CM1.adapter;
};

CM1.ImpactEstimate = ImpactEstimate;
CM1.ImpactEstimator = ImpactEstimator;
 
// ## Deploy With Browserify
// 
// CM1.js can be used with [browserify](http://github.com/substack/node-browserify).
// Simply `npm install CM1` and `require('CM1')` in your code.

module.exports = CM1;

});

require.define("/lib/impact-estimate.js", function (require, module, exports, __dirname, __filename) {
var ImpactEstimate = module.exports = function(subject, data) {
  this.subject = subject;
  this.data = data;

  if(data.decisions.carbon)
    this.carbon = data.decisions.carbon.object.value;
  proxyDataProperties(this, data);
};

var proxyDataProperties = function(estimate, data) {
  for (var property in data) {
    if(!data.hasOwnProperty(property)) continue;

    estimate[property] = data[property];
  }
};

});

require.define("/lib/impact-estimator.js", function (require, module, exports, __dirname, __filename) {
var ImpactEstimate = require('./impact-estimate');

var ImpactEstimator = module.exports = function(cm1) {
  this.cm1 = cm1;
};

ImpactEstimator.callbacks = {
  getImpacts: function(subject, callback) {
    return function(err, impacts) {
      if(err) {
        callback(err);
      } else {
        subject.impacts = impacts;
        callback(null, impacts);
      }
    }
  }
};

ImpactEstimator.prototype.params = function(subject) {
  var params = {};
  for(var cm1_field in this.cm1.attributeMap) {
    var attribute = this.cm1.attributeMap[cm1_field];
    var value = subject[attribute];
    var result = null;
    if(value)
      result = value;
    if(typeof result == 'function')
      result = result.apply(subject);
    if(result)
      params[cm1_field] = result;
  }

  if(this.cm1.key()) {
    params.key = this.cm1.key();
  }

  if(subject.parameters) {
    for(var i in subject.parameters) {
      params[i] = subject.parameters[i];
    }
  }

  return params;
};

ImpactEstimator.prototype.getImpacts = function(subject, callback) {
  this.cm1.adapter().getImpacts(this.cm1, subject, this.params(subject),
                                ImpactEstimator.callbacks.getImpacts(subject, callback));
};

});

require.define("/lib/adapters/http-adapter.js", function (require, module, exports, __dirname, __filename) {
var http = require('http');

var ImpactEstimate = require('../impact-estimate'),
    Util = require('../util');

var HttpAdapter = module.exports = function() {
  this.host = 'impact.brighterplanet.com';
};

HttpAdapter.prototype.path = function(cm1) {
  return '/' + Util.pluralize(cm1.model) + '.json';
};

HttpAdapter.prototype.getImpacts = function(cm1, subject, params, callback) {
  var body = JSON.stringify(params);
  var req = http.request({
    host: this.host, port: 80, path: this.path(cm1),
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': body.length
    }
  }, function (res) {
    var data = '';
    res.on('data', function (buf) {
      data += buf;
    });

    res.on('error', function() {
      var err = new Error('Failed to get impact estimate: ' + data);
      callback(err);
    });

    res.on('end', function () {
      var json = JSON.parse(data);
      subject.impacts = new ImpactEstimate(subject, json);
      callback(null, subject.impacts);
    });
  });
  req.end(body);
};

});

require.define("/lib/util.js", function (require, module, exports, __dirname, __filename) {
var Util = module.exports = {
  pluralize: function(str) {
    return str + 's';
  }
};

});

require.define("/lib/adapters/websocket-adapter.js", function (require, module, exports, __dirname, __filename) {
var CM1 = require('../cm1');

var ImpactEstimate = require('../impact-estimate'),
    Util = require('../util');

var WebsocketAdapter = module.exports = function() {
  process.env = process.env || {};
  var hostname = process.env.CM1_WEBSOCKET_HOST || CM1.websocketHost || 'push-brighterplanet.no.de:80';
  if(!/^http:/.test(hostname)) hostname = 'http://' + hostname;
  this.host = hostname;
};

WebsocketAdapter.callbacks = {
  getImpacts: function(subject, callback) {
    return function(response) {
      if(response.statusCode < 300) {
        var body = JSON.parse(response.body);
        subject.impacts = new ImpactEstimate(subject, body);
        callback(null, subject.impacts);
      } else {
        callback(response.body);
      }
    };
  }
};

WebsocketAdapter.prototype.connect = function() {
  var socketIo = 'socket.io-client';
  this.socket = require(socketIo).connect(this.host);
};

WebsocketAdapter.prototype.getImpacts = function(cm1, subject, params, callback) {
  var request = {
    'PATH_INFO': '/' + Util.pluralize(cm1.model) + '.json',
    'body': JSON.stringify(params)
  };
  if(!this.socket) this.connect();
  this.socket.emit('impacts', request,
                   WebsocketAdapter.callbacks.getImpacts(subject, callback));
};

});

require.define("/lib/cm1.js", function (require, module, exports, __dirname, __filename) {
// Carbon, energy, and other environmental impact calculations for your 
// JavaScript objects. Built for the browser and Node.js.
var ImpactEstimate = require('./impact-estimate'),
  ImpactEstimator = require('./impact-estimator');

var CM1 = function() {
  this.attributeMap = {};
};

// ## Usage
// For a quick, **one-off calculation**, you can use `CM1.impacts()`. Here's an example for a flight:
// 
//     var CM1 = require('cm1');
//     CM1.impacts('flight', {
//       origin_airport: 'IAD',
//       destination_airport: 'PDX',
//       airline: 'United',
//       trips: 2,
//       segments_per_trip: 1    // nonstop flight
//     },
//     function(err, impacts) {
//       if(err) return console.log('Argh, falied!', err);
// 
//       console.log('Carbon for my cross-country flight: ',
//                   impacts.carbon);
//       console.log('Methodology: ', impacts.methodology);
//     });
// 
CM1.impacts = function(type, properties, callback) {
  var model = CM1.model(type, properties);
  model.getImpacts(callback);
};

// Alternatively, `CM1.model()` can add impact calculation abilities to an
// **existing object** on which you can run calculations at a later time:
// 
//     var CM1 = require('cm1');
//     var model = CM1.model('flight', {
//       origin_airport: 'JFK',
//       destination_airport: 'Berlin',
//       airline: 'Luftansa'
//     });
// 
//     // later...
//     model.seat_class = 'Business';
// 
//     model.getImpacts(function(err, impacts) {
//       if(err) return console.log('Argh, falied!', err);
// 
//       console.log('Carbon for my international flight: ',
//                   impacts.carbon);
//       console.log('Methodology: ', impacts.methodology);
//     });
// 
CM1.model = function(type, properties) {
  var attributes = Object.keys(properties);

  var proto = function() {};
  CM1.extend(proto, {
    model: type,
    provides: attributes
  });

  var object = new proto();
  for(var i = 0; i < attributes.length; i++) {
    var attribute = attributes[i];
    object[attribute] = properties[attribute];
  }

  return object;
};

// You can also **extend any prototype** (class) to become and impact calculating machine. For example, let's
// say we have a class representing a rental car:
// 
// 
//     var RentalCar = function() {};
//     
//     var car = new RentalCar();
//     car.make = 'Honda';
//     car.model = 'Fit';
//     car.fuelEconomy = 36.7;
// 
// If you want to figure out how much CO2 it emits, use `CM1.extend()` to tell
// your prototype how to use CM1 to calculate impacts. The first argument is the
// prototype to extend, the second argument is a object that describes mappings
// between properties of your prototype instance to the characteristics sent to
// CM1. After executing `CM1.extend()`, A new function called `getImpacts()`
// will be added to your class. `CM1.extend()` must be run before instantiating
// the RentalCar.
// 
//     var RentalCar = function() {};
//     
//     CM1.extend(RentalCar, {
//       model: 'automobile',
//       provides: ['make', 'model', {
//         'fuel_efficiency': 'fuelEconomy'
//       }
//     });
// 
// This says "my RentalCar prototype will use the
// [Automobile emitter](http://carbon.brighterplanet.com/models/automobile) to calculate
// impacts. It uses the make property to provide make to the web service, model maps to
// model, and the fuelEconomy property maps to fuel_efficiency on CM1.
//
// Now you can calculate impacts:
// 
//     var car = new RentalCar();
//     car.make = 'Honda';
//     car.model = 'Fit';
//     car.fuelEconomy = 36.7;
// 
//     car.getImpacts(function(err, impacts) {
//       if(err) alert("Oops, something broke: " + err);
//  
//       alert("My emissions are: " + impacts.carbon);
//       alert("My fuel use is: " + impacts.fuelUse);
//     });
//
// There are a whole bunch of [other models](http://carbon.brighterplanet.com/models)
// available, including computer usage, rail trips, and flights.
// 
CM1.extend = function(klass, mapping) {
  klass.cm1 = new CM1();
  klass.cm1.define(mapping);
  klass.prototype.impactEstimator = new ImpactEstimator(klass.cm1);
  klass.prototype.getImpacts = function(callback) {
    return this.impactEstimator.getImpacts(this, callback);
  };
};

// ## Specifying an API Key
// 
// CM1 is free for non-commercial use and available for commercial use. In either 
// case, you need to sign up for a Brighter Planet API key if you haven't already.
// To do so, go to [keys.brighterplanet.com](http://keys.brighterplanet.com).
// 
// Once you have your key, you can specify it with:
// 
//     var CM1 = require('CM1');
//     process.env.CM1_KEY = 'ABC123';
//     
// Note: if using the stand-alone library, `process.env` won't be available in your
// browser until you `require('CM1')`.
// 
CM1.prototype.key = function() {
  if(process && process.env && process.env.CM1_KEY)
    return process.env.CM1_KEY;
  else
    return CM1.key;
};

// ## Connection Adapters: HTTP, Websockets, etc.
// CM1.js can use a **standard RESTful HTTP** adapter (default) or an **HTML5 Websockets** adapter.

// The **standard HTTP** adapter sends a separate HTTP request for each calculation 
// performed. This is ideal for when one or only a few calculations are made at 
// a given time.
CM1.useHttpAdapter = function() {
  CM1.setAdapter('http');
};

// The **Websockets** adapter is ideal for when many calculations need to be made at once.
// You will need to `npm install socket.io-client` to use this.
CM1.useWebsocketAdapter = function() {
  CM1.setAdapter('websocket');
};

// You can define process.env.CM1_ADAPTER to 'http' or 'websocket'. 
// Otherwise, CM1 defaults to the HTTP adapter
CM1.setAdapter = function(type) {
  process.env = process.env || {};
  type = type || process.env.CM1_ADAPTER || 'http';
  var adapter = type == 'http' ? 
    require('./adapters/http-adapter') :
    require('./adapters/websocket-adapter');
  CM1.adapter = new adapter();
};

// ## Etc.
// Apply a mapping to a CM1-enabled object.
CM1.prototype.define = function(mapping) {
  this.emitAs(mapping.model);
  var provisions = mapping.provide || mapping.provides;
  this.provide(provisions);
};

// Set the model (e.g. flight) used for calculation.
CM1.prototype.emitAs = function(model) {
  this.model = model;
};

// Define the properties of the CM1-enabled object that are sent as
// characteristics to CM1's models.
// The format of **attributes** can be:
//
// * `['foo', 'bar', 'baz']`
// * `['foo', 'bar', 'baz', { quux: 'quuxValue' }]`
// * `{ foo: 'fooProperty',  quux: 'quuxValue' }`
//
// When specifying an object parameter, the property name
// is the name of the CM1 characterstic, and the value is
// the name of the property or function on your object that
// holds the data to be sent.
CM1.prototype.provide = function(attributes) {
  for(var i in attributes) {
    if(attributes.hasOwnProperty(i)) {
      var value = attributes[i];
      if(typeof value == 'object') {
        this.provide(value);
      } else if(/^\d+$/.test(i)) {
        this.attributeMap[this.underscore(value)] = value;
      } else {
        this.attributeMap[this.underscore(i)] = value;
      }
    }
  }
};

CM1.prototype.underscore = function(string) {
  return string.replace(/([a-z])([A-Z])/g, function(str, first, second) {
    return first + '_' + second.toLowerCase();
  });
};

CM1.prototype.adapter = function() {
  if(!CM1.adapter) CM1.setAdapter();
  return CM1.adapter;
};

CM1.ImpactEstimate = ImpactEstimate;
CM1.ImpactEstimator = ImpactEstimator;
 
// ## Deploy With Browserify
// 
// CM1.js can be used with [browserify](http://github.com/substack/node-browserify).
// Simply `npm install CM1` and `require('CM1')` in your code.

module.exports = CM1;

});

require.define("/test-pre.js", function (require, module, exports, __dirname, __filename) {
    var test = require('testling'),
    CM1 = require('./lib/CM1');

test('CM1.impacts', function(t) {
  t.plan(3);

  CM1.impacts('flight', {
    origin_airport: 'IAD',
    destination_airport: 'PDX',
    airline: 'United',
    trips: 2,
    segments_per_trip: 1
  },
  function(err, impacts) {
    t.notOk(err);
    t.ok(impacts.carbon > 0);
    t.ok(impacts.methodology);
    t.end();
  });
});

});
require("/test-pre.js");
